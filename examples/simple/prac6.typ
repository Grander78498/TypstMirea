#import ("/src/titul.typ"): *
#import ("/src/preamble.typ"): *
#show: main
#titul(
  Институт: [Информационных Технологий],
  Кафедра: [Вычислительной Техники],
  Практика: [Практическая работа №6\
            "Электромагнитный алгоритм"],
  Дисциплина: ["Системный анализ данных СППР"],
  Группа: [ИКБО-04-22],
  Студент: [Егоров Л.А.],
  Преподаватель: [Железняк Л.М.]
)
#show: template

#outline()

#heading("Введение", numbering: none)
Электромагнитный алгоритм предложен Бирбилом (I. Birbil) и Фангом (S.C. Fang) в 2003 году [2]. Этот алгоритм вдохновлен фундаментальными принципами электромагнетизма, а именно взаимодействием между электрическими зарядами и магнитными полями.

В алгоритме пространство поиска представляется как заполненное частицами, каждая из которых обладает определенным электрическим зарядом. Эти частицы взаимодействуют друг с другом посредством электромагнитных сил. Сила притяжения или отталкивания между двумя частицами зависит от их зарядов и расстояния между ними.

Каждого из агентов популяции в электромагнитном алгоритме интерпретируют как заряженную частицу, заряд которой пропорционален значению фитнесс-функции в той точке области поиска, в которой на данной итерации находится агент. Текущий заряд частиц популяции определяет суммарную силу, действующую на данную частицу со стороны других частиц, а также направление и величину её перемещений на текущей итерации. В соответствии с законами электростатики эта сила вычисляется путём векторного суммирования сил притяжения и отталкивания со стороны всех частиц популяции [2].

Электромагнитный алгоритм широко используется для решения различных задач оптимизации, таких как:
-	задача коммивояжера
-	распределение ресурсов
-	планирование
-	сетевое проектирование

= Электромагнитный алгоритм
== Описание алгоритма
Сначала происходит инициализация начальных параметров и зарядов – генерация точек в области поиска (количество точек задано и равно S), а также свободных параметров алгоритма. Каждая точка имеет координаты @electro-coord.

$ X_j=(x_1j,x_2j,…,x_(n j) )	$<electro-coord>

#print_symbols(
  [$j in [1;S]$ --- номер частицы],
  [n --- размерность векторов в задаче]
)

Затем начинается локальный поиск – для каждого заряда выполняется линейный стохастический поиск @local-search в целях сбора локальной информации об окружении частиц [2, c.22-23].

$ x_(i j)^'= x_(i j) + u^"sign" * U(0;1) * alpha (x^+ - x^-) $<local-search>

#print_symbols(
  [$u^"sign"$ --- случайное целое число, равное -1 или 1],
  [$U(0;1)$ --- случайное число от 0 до 1 из равномерного распределения],
  [$alpha in (0;1)$ --- свободный параметр алгоритма],
  [$x^+, x^-$ --- границы рассматриваемой области поиска]
)

При этом, изменённая координата принимается только в том случае, если её изменение дало улучшение значения целевой функции, иначе происходит переход к следующей итерации локального поиска.

Как правило, свободный параметр $alpha$ задаётся близким к нулю (порядка $~10^(-2):10^(-4)$), поэтому локальный поиск служит только для незначительного улучшения положения точек в пространстве.

После осуществления локального поиска вычисляется лучшая точка, т.е. точка, где достигается минимальное среди всех значение целевой функции.

Затем для каждой частицы вычисляется её заряд по Формуле @charge.

$ q_i = exp(-n * ( (φ_i-φ_"best" ) ) / ( sum_(j, j cancel(eq) i) (φ_j-φ_"best" ) )) $<charge>

#print_symbols(
  [$phi_i$ --- значение целевой функции в текущей точке],
  [$phi_"best"$ --- значение целевой функции в лучшей точке]
)

На основе посчитанных зарядов происходит вычисление силы отталкивания и притяжения между частицами (@force). Частица i отталкивается от частицы j, если значение функции у частицы i лучше, чем значение функции у частицы j, и наоборот, притягивается, если значение функции хуже.

$ F_i = sum_(j=1, j cancel(eq) i)^S F_(i,j) = sum_(j=1, j cancel(eq) i)^S cases(
  (X_j - X_i) frac(q_i q_j, ||X_j - X_i||^2) ", если " phi_j < phi_i,
  (X_i - X_j) frac(q_i q_j, ||X_j - X_i||^2) ", если " phi_i < phi_j
) $<force>

Таким образом, лучшая частица на данной итерации притянет к себе все остальные. Далее выполняется перемещение частиц, высчитываемое на основе электромагнитных сил (@electro-change).

$ X_i (t+1) = X_i (t) + U(0;1) F_i/(||F_i||) V_i $<electro-change>

#print_symbols(
  [$U(0;1)$ --- случайное число от 0 до 1 из равномерного распределения],
  [$frac(F_i, || F_i ||)$ --- нормированный вектор силы],
  [$V_i$ --- вектор скорости, компоненты которого рассчитываются по Формуле @electro-speed]
)

$ v_(i j) = cases(
  (x^+ - x_(i j)) ", " F_(i j) > 0,
  (x_(i j) - x^-) ", " F_(i j) <= 0
) ", " j in [1:S] ", " j != i $<electro-speed>

#print_symbols(
  [$x^+,x^-$ --- границы области поиска]
)

Важно отметить, что лучшая частица должна остаться на своём месте, поэтому она в данной итерации не передвигается, а только притягивает к себе другие частицы.

После осуществления перемещения частиц происходит переход к следующей итерации. Точкой останова алгоритма является достижение максимального числа итераций.


== Постановка задачи

Цель работы: реализовать электромагнитный алгоритм для нахождения оптимального значения функции.

Поставлены следующие задачи:

- изучить электромагнитный алгоритм
- выбрать тестовую функцию для оптимизации (нахождение глобального минимума)
- произвести ручной расчёт одной итерации алгоритма
- разработать программную реализацию электромагнитного алгоритма для задачи минимизации функции

Выбранная функция для оптимизации: функция Растригина (@rastrigin-4). Она примечательна тем, что имеет большое количество локальных минимумов. Глобальный минимум функции достигается в точке $(0;0)$ и равен 0, при этом, в остальных локальных минимумах значение функции больше нуля. Функция рассматривается на области $x_i in [-5.12,5.12]$.

$ f(x,y)=20+x^2-10 cos(2 pi x)+y^2-10 cos(2 pi y) $<rastrigin-4>

== Ручной расчёт алгоритма

Выбранная функция: функция Растригина от двух переменных. Её формула представлена Формулой @rastrigin-4.
На Рисунке @rastrigin-im-4 представлен график этой функции.

#figure(image("/img/prac6_2025-02-07-17-16-04.png"), caption: [График функции Растригина])<rastrigin-im-4>

Количество частиц, используемых для ручного расчёта: 4.

Создано 4 частицы со следующими координатами:

#eq-simple($ X_1 = (-1.911, 2.375); f(X_0) = 27.905 \
X_2 = (3.325, 4.537); f(X_1) = 65.893 \
X_3 = (3.839, -2.436); f(X_2) = 44.592 \
X_4 = (0.141, -1.939); f(X_3) = 8.157 \
$)
После выполнения локального поиска (@local-search) точки имеют следующие координаты:

#eq-simple($ X_1 = (-1.911, 2.368); f(X_0) = 27.550 \
X_2 = (3.291, 4.537); f(X_1) = 63.706 \
X_3 = (3.873, -2.436); f(X_2) = 43.152 \
X_4 = (0.141, -1.961); f(X_3) = 7.813 \
$)
При этом, значение $phi_"best"$ равно 7.813 в точке $(0.141, -1.961)$.
Далее приведены расчёты значения заряда для каждой из частиц по Формуле @charge:

#eq-simple($ q_1 = exp(-2 * (27.550 - 7.813)/110.971) = 0.701 \
q_2 = exp(-2 * (63.706 - 7.813)/110.971) = 0.365 \
q_3 = exp(-2 * (43.152 - 7.813)/110.971) = 0.529 \
$)
При этом, заряд у лучшей частицы будет равен единице, поскольку аргумент в экспоненте будет равен нулю.
Затем вычисляются значение силы для каждой частицы по Формуле @force:

#eq-simple($ F_1 =& 0.701 * 0.365 * ((-1.911, 2.368) - (3.291, 4.537))/31.766 + \ &+ 0.701 * 0.529 * ((-1.911, 2.368) - (3.873, -2.436))/56.543 + \ &+ 0.701 * 1.000 * ((0.141, -1.961) - (-1.911, 2.368))/22.953 = (-0.017, -0.118) \
F_2 =& 0.365 * 0.701 * ((-1.911, 2.368) - (3.291, 4.537))/31.766 + \ &+ 0.365 * 0.529 * ((3.873, -2.436) - (3.291, 4.537))/48.965 + \ &+ 0.365 * 1.000 * ((0.141, -1.961) - (3.291, 4.537))/52.152 = (-0.062, -0.09) \    
F_3 =& 0.529 * 0.701 * ((-1.911, 2.368) - (3.873, -2.436))/56.543 + \ &+ 0.529 * 0.365 * ((3.873, -2.436) - (3.291, 4.537))/48.965 + \ &+ 0.529 * 1.000 * ((0.141, -1.961) - (3.873, -2.436))/14.160 = (-0.175, 0.022) \  
F_4 =& 1.000 * 0.701 * ((0.141, -1.961) - (-1.911, 2.368))/22.953 + \ &+ 1.000 * 0.365 * ((0.141, -1.961) - (3.291, 4.537))/52.152 + \ &+ 1.000 * 0.529 * ((0.141, -1.961) - (3.873, -2.436))/14.160  = (-0.099, -0.16) 
\
$)

И наконец, позиции частиц изменяются по Формулам @electro-change - @electro-speed. Частица $X_4$ не передвигается, т.к. она имеет лучшее значение.

Рассчитаем смещение для 1-й частицы. Сгенерировано случайное число $U(0;1) = 0.845$.

Нормированный вектор силы у 1-й частицы: $F_1 = (-0.144, -0.99)$.

Рассчитаны компоненты вектора скорости для 1-й частицы:

#eq-simple($ v_11 = -1.911 + 5.12 = 3.209 \
v_12 = 2.368 + 5.12 = 7.488 \
$)
Тогда частица сместится на следующую позицию:

#eq-simple($ X_1 &= (-1.911, 2.368) + 0.845 * (-0.144, -0.99) * (3.209, 7.488) \ &= (-2.301, -3.891) \
F(X_1) &= 35.864
$)

Рассчитаем смещение для 2-й частицы. Сгенерировано случайное число $U(0;1) = 0.403$
Нормированный вектор силы у 2-й частицы: $F_2 = (-0.563, -0.826)$
Рассчитаны компоненты вектора скорости для 2-й частицы:

#eq-simple($ v_21 = 3.291 + 5.12 = 8.411 \
v_22 = 4.537 + 5.12 = 9.657 \
$)
Тогда частица сместится на следующую позицию:

#eq-simple($ X_2 &= (3.291, 4.537) + 0.403 * (-0.563, -0.826) * (8.411, 9.657) \ &= (1.38, 1.317) \
F(X_2) &= 35.025
$)

Рассчитаем смещение для 3-й частицы. Сгенерировано случайное число $U(0;1) = 0.767$
Нормированный вектор силы у 3-й частицы: $F_3 = (-0.992, 0.123)$
Рассчитаны компоненты вектора скорости для 3-й частицы:

#eq-simple($ v_31 = 3.873 + 5.12 = 8.993 \
v_32 = 5.12 + 2.436 = 7.556 \
$)
Тогда частица сместится на следующую позицию:

#eq-simple($ X_3 &= (3.873, -2.436) + 0.767 * (-0.992, 0.123) * (8.993, 7.556) \ &= (-2.973, -1.722) \
F(X_3) &= 23.689
$)

== Программная реализация
Для реализации расчётов электромагнитного алгоритма написан программный код на языке Python.

В программной реализации зафиксированы следующие параметры:

- количество частиц: 20
- количество итераций локального поиска: 10
- количество общих итераций: 100
- $alpha = 0.005$

Код реализации электромагнитного алгоритма для нахождения оптимального значения функции представлен в Листинге @electro-code.

На Рисунке @electro-result представлен результат выполнения программы для нахождения оптимального значения функции – график зависимости минимального оптимального решения от номера итерации. 

#figure(image("/img/prac6_2025-02-07-17-42-30.png"), caption: [Результат выполнения программы])<electro-result>

#heading([Заключение], numbering: none)
В ходе выполнения данной работы выполнены поставленные задачи – изучен электромагнитный алгоритм, произведён его ручной расчёт для решения задачи поиска глобального минимума функции, а также разработаны программы на языке Python для нахождения глобального минимума функции Растригина от двух переменных.

В заключение можно отметить, что электромагнитный алгоритм является мощным инструментом для решения задач оптимизации (например, для нахождения глобального минимума функции от нескольких переменных), в которых стандартные методы недостаточно эффективны из-за наличия множества локальных минимумов. Алгоритм имеет меньшую зависимость от свободных параметров, чем пчелиный алгоритм, но большую, чем роевой алгоритм. В то же время, алгоритм показал быструю сходимость, однако имеет тенденцию сходится к локальным минимумам.



#bibliography("/authors.bib", style: "/gost-r-7-0-5-2008-numeric-alphabetical.csl", title: "Список использованных источников", full: true)

#appendix()

==== Реализация электромагнитного алгоритма на языке Python

#simple-code(raw(read("/include/electro.py")),
             "Реализация электромагнитного алгоритма",
             label: <electro-code>)