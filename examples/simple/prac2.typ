#import ("/src/titul.typ"): *
#import ("/src/preamble.typ"): *
#show: main
#titul(
  Институт: [Информационных Технологий],
  Кафедра: [Вычислительной Техники],
  Практика: [Практическая работа №2\
            "Метод имитации отжига"],
  Дисциплина: ["Системный анализ данных СППР"],
  Группа: [ИКБО-04-22],
  Студент: [Егоров Л.А.],
  Преподаватель: [Железняк Л.М.]
)
#show: template

#outline()

#heading("Введение", numbering: none)
Метод имитации отжига — это алгоритм оптимизации, основанный на принципах физического процесса отжига, в котором материал медленно охлаждается с целью достижения состояния минимальной энергии.

Алгоритм имитации отжига предложен в 1953 году Метрополисом (N.C. Metropolis). Данный алгоритм можно считать одним из немногих универсальных алгоритмов решения задач глобальной оптимизации.

Метод имитации отжига особенно актуален в современных условиях, когда многие задачи оптимизации стали слишком сложными для традиционных методов. С увеличением объёма данных и усложнением систем возникает необходимость в алгоритмах, способных находить решения в условиях высокой размерности и множества локальных минимумов. Имитация отжига предоставляет эффективный способ решения таких задач за счёт своей способности преодолевать локальные оптимумы и исследовать глобальные решения, что делает метод востребованным в разнообразных отраслях.

Метод имитации отжига находит широкое применение в таких сферах, как логистика и транспорт (например, для решения задач маршрутизации и оптимизации цепей поставок), телекоммуникации (для оптимизации сетевых ресурсов), экономика (для моделирования и оптимизации портфелей инвестиций), проектирование сложных инженерных систем (например, для оптимального размещения элементов на печатных платах), а также в биоинформатике и химии (для решения задач структурной биологии и моделирования молекул).
= Метод имитации отжига
== Описание алгоритма
Алгоритм имитации отжига состоит из следующих шагов:

+ Задание начальных параметров --- выбор случайного начального решения и заданного значения температуры.
+ Генерация нового решения в окрестности текущего и оценка его качества.
+ Если новое решение лучше текущего, то алгоритм переходит к нему. Если нет, то переход всё равно может быть выполнен с некоторой вероятностью, зависящей от температуры и разности в качестве решений (@prob).

$ h(X, T) = cases(1 ", если " f(X') - f(X) < 0, e^(-frac(Delta E, T)) ", если " f(X') - f(X) >= 0) $<prob>

4. После этого шага температура снижается по заданному закону, и происходит переход к шагу 2.
5. Точкой останова алгоритма является достижение температурой определённого порога.

== Постановка задачи
Цель работы: реализовать метод имитации отжига для решения задачи коммивояжёра и нахождения оптимального значения функции.

Поставлены следующие задачи:
- изучить метод имитации отжига
- выбрать предметную область для задачи коммивояжёра и функцию для оптимизации
- расписать ручной расчёт двух итераций в каждой из задач
- разработать программный код решения задач методом имитации отжига

Условие задачи коммивояжёра: дан полный граф, т.е. из каждой вершины можно пройти в любую другую вершину. В этом графе нужно найти полный путь минимальной длины, т.е. обойти каждую вершину в графе по одному разу.

Нахождение глобального минимума функции от многих переменных состоит в поиске точки в многомерном пространстве, где значение функции будет минимальным. Сложность этой задачи состоит в том, что функция может содержать множество локальных минимумов, где производная функция равна нулю, но значение функции не является минимальным.

Выбранная предметная область для задачи коммивояжёра: в торговом центре расположено n магазинов. Человеку нужно пройтись по всем этим магазинам, при этом ему нужно затратить как можно меньше усилий на это, т.е. общий пройденный путь должен быть минимально возможным. Поэтому нужно определить минимальный путь, позволяющий обойти все магазины.

Выбранная функция для оптимизации: функция Растригина (@rastrigin). Она примечательна тем, что имеет большое количество локальных минимумов. Глобальный минимум функции достигается в точке $(0;0)$ и равен 0, при этом, в остальных локальных минимумах значение функции больше нуля. Функция рассматривается на области $x_i in [-5.12, 5.12]$.

$ f(x, y) = 20 + x^2 - 10 cos(2pi x) + y^2 - 10cos(2pi y) $<rastrigin>
#v(-18pt)

== Задача коммивояжёра
=== Математическая модель
Для ручного расчёта число магазинов в задаче взято равным 6. Для каждого магазина случайным образом сгенерированы координаты в двумерном пространстве (диапазон координат от -10 до 10). Эти данные представлены заданы в Таблице @store.

#let data = csv("/include/backup_6.csv")
#simple-table(columns: 3,
              name: "Характеристики магазинов",
              header: ([Номер магазина], [Координата по x], [Координата по y]), 
              label: <store>, 
              ..data.slice(1, data.len()).flatten())

Важно, что у дома нулевые координаты.

Для расчёта расстояний между вершинами в графе использовалось Евклидово расстояние для точек в двумерном пространстве (@euclid).

$ d = sqrt((x_2 - x_1)^2 - (y_2 - y_1)^2) $<euclid>

Ниже приведены расчёты длины каждого ребра в графе, т.е. рассчитаны длины путей между каждой парой вершин.

#eq-simple($ sqrt((92 + 67)^2 + (-97 - 28)^2) = 202.25 \
sqrt((92 + 14)^2 + (-97 + 90)^2) = 106.23 \
sqrt((92 + 67)^2 + (-97 - 72)^2) = 232.04 \
sqrt((92 - 19)^2 + (-97 - 75)^2) = 186.85 \
sqrt((92 - 77)^2 + (-97 + 97)^2) = 15.0 \
sqrt((-67 + 14)^2 + (28 + 90)^2) = 129.36 \
sqrt((-67 + 67)^2 + (28 - 72)^2) = 44.0 \
sqrt((-67 - 19)^2 + (28 - 75)^2) = 98.01 \
sqrt((-67 - 77)^2 + (28 + 97)^2) = 190.69 \
sqrt((-14 + 67)^2 + (-90 - 72)^2) = 170.45 \
sqrt((-14 - 19)^2 + (-90 - 75)^2) = 168.27 \
sqrt((-14 - 77)^2 + (-90 + 97)^2) = 91.27 \
sqrt((-67 - 19)^2 + (72 - 75)^2) = 86.05 \
sqrt((-67 - 77)^2 + (72 + 97)^2) = 222.03 \
sqrt((19 - 77)^2 + (75 + 97)^2) = 181.52 $)


Рассчитанные длины рёбер сведены в Таблицу @length с указанием вершин, составляющих ребро.
#simple-table(name: "Длины рёбер в графе",
              header: ([Ребро], [Длина ребра]), 
              label: <length>, 
              [0 #math.arrow 1], [ 202.25],
              [0 #math.arrow 2], [ 106.23],
              [0 #math.arrow 3], [ 232.04],
              [0 #math.arrow 4], [ 186.85],
              [0 #math.arrow 5], [ 15.00],
              [1 #math.arrow 2], [ 129.36],
              [1 #math.arrow 3], [ 44.00],
              [1 #math.arrow 4], [ 98.01],
              [1 #math.arrow 5], [ 190.69],
              [2 #math.arrow 3], [ 170.45],
              [2 #math.arrow 4], [ 168.27],
              [2 #math.arrow 5], [ 91.27],
              [3 #math.arrow 4], [ 86.05],
              [3 #math.arrow 5], [ 222.03],
              [4 #math.arrow 5], [ 181.52]
              )

=== Ручной расчёт
Сначала нужно составить путь случайным образом:
$0 -> 4 -> 5 -> 3 -> 2 -> 6 -> 1 -> 0$.
Длина полученного пути: $S_0 = 10.82 + 10.82 + 5.0 + 12.65 + 5.39 + 10.3 + 5.0 + 5.0 + 6.0 + 6.0 = 76.96 (м)$.

За изначальную температуру взята $T_0 = 100$.

Для первой итерации вместо четвёртого магазина поставлен пятый магазин, и после этого перестроен путь:
$0 -> 5 -> 4 -> 3 -> 2 -> 6 -> 1 -> 0$.
После этого проводится расчёт длины текущего пути: $S_1 = 5.0 + 7.81 + 15.81 + 10.3 + 8.06 + 8.06 + 10.82 + 10.82 + 5.0 + 5.0 = 86.68 (м)$.
Длина текущего пути оказалась больше длины лучшего пути, поэтому проводится расчёт вероятности перехода к текущему решению.

#eq-simple($ H = e^(-frac(Delta l, T_0)) = e^(-(86.68-76.96)/100) approx 0.378 $)

Вероятность, выданная псевдослучайным генератором чисел от 0 до 1, равна 0.363, что меньше 0.378. Поэтому текущее решение принимается как лучшее.

В конце первой итерации температура уменьшается в два раза по сравнению с изначальной: $T_1 = T_0 / 2 = 100 / 2 = 50$.

Для второй итерации на место третьего магазина поставлен шестой, после чего перестроен путь:
$0 -> 5 -> 1 -> 2 -> 6 -> 3 -> 4 -> 0$.

Длина получившегося пути равна $S_2 = 5.0 + 7.81 + 15.81 + 10.3 + 5.0 + 7.62 + 8.06 + 10.82 + 10.82 = 81.23 (м)$.

Длина получившегося пути меньше длины лучшего пути, поэтому текущее решение сразу принимается.

В конце второй итерации температура уменьшается в два раза по сравнению с температурой на текущей итерации: $T_2 = T_1 / 2 = 50 / 2 = 25$.

== Поиск глобального минимума
Выбранная функция: функция Растригина от двух переменных. Её формула представлена формулой @rastrigin.

На Рисунке @rastr-im представлен график этой функции.

#figure(image("/img/main2_rastrigin.png", height: 30%), caption: [График функции Растригина])<rastr-im>

Координаты начальной точки сгенерированы случайным образом и равны (2.75, 3.17). Значение функции в этой точке равно 32.53.

На первой итерации температура равна $T_0 = 100$.

Текущее решение на каждой итерации генерируется с использованием распределения Коши (@cauchy), где $D = 2$, т.к. задача рассматривается в двумерном пространстве.

$ g(x, x', T) = 1 / pi^D product_(i = 1)^D T / (abs(x' - x)^2 + T^2) $<cauchy>

Текущее решение на первой итерации: (4.7, 5). Значение функции в этой точке равно 60.18.

Поскольку текущее решение оказалось хуже лучшего, то проводится расчёт вероятности перехода к этому решению.

#eq-simple($ H=e^(-(Delta f) / T_0 ) = e^(-(60.18-32.53)/100) approx 0.758 $)

Вероятность, выданная псевдослучайным генератором чисел от 0 до 1, равна 0.923, что больше 0.758. Поэтому текущее решение отбрасывается. Лучшее решение после первой итерации: (2.75, 3.17), значение функции: 32.53.

После выполнения первой итерации температура изменена в соответствии с законом Коши.

#eq-simple($ T_1 = T_0 / k^(1/D) = 100 / 1^(1/2) = 100 $)

При переходе на вторую итерацию текущим решением выбрано: (1.23, 1.35). Значение функции в этой точке равно 27.96.

Текущее решение оказалось оптимальнее лучшего, поэтому оно автоматически принимается. Лучшее решение после второй итерации: (1.23, 1.35), значение функции: 27.96.

После выполнения второй итерации температура изменена в соответствии с законом Коши.

#eq-simple($ T_2 = T_0 / k^(1/D) = 100 / 2^(1/2) approx 70,711 $)

== Программная реализация
Для реализации расчётов метода имитации отжига написан программный код на языке Python.

В программной реализации задачи коммивояжёра зафиксированы следующие параметры:
- количество магазинов: 10
- диапазон координат магазинов: $[-100; 100]$

Код, реализующий решение поставленной задачи коммивояжёра методом имитации отжига, представлен в Листинге @otzhig-gen. Код, отвечающий за генерацию данных для задачи, представлен в Листинге @otzhig-data, а сгенерированные данные представлены в Листинге @otzhig.

На Рисунке @otzh-path представлен результат выполнения программы, решающей задачу коммивояжёра --- построенный граф после завершения алгоритма. Вертикальная и горизонтальная оси являются координатными осями.

#figure(image("/img/main2_otzh-path.png", height: 35%), caption: [Построенный минимальный путь в графе])<otzh-path>

На Рисунке @otzh-graph представлен график, отражающий изменение длины пути в графе в течение выполнения итераций алгоритма.

#figure(image("/img/main2_otzh-graph.png"), caption: [График изменения длины пути])<otzh-graph>
 
Код реализации имитации отжига методом Коши для нахождения оптимального значения функции представлен в Листинге @cauchy-code.

На Рисунке @cauchy-res представлен результат выполнения программы для нахождения оптимального значения функции --- график зависимости оптимального решения от номера итерации.

#figure(image("/img/main2_cauchy-res.png"), caption: [График зависимости оптимального значения функции от номера итерации])<cauchy-res>

#heading("Заключение", numbering: none)
В ходе выполнения данной работы выполнены поставленные задачи – изучен метод имитации отжига, произведён его ручной расчёт для решения задачи коммивояжера и задачи поиска глобального минимума функции, а также разработаны программы на языке Python для решения поставленной задачи коммивояжёра – обхода всех магазинов, и для нахождения глобального минимума функции Растригина от двух переменных.

В заключение можно отметить, что метод имитации отжига является мощным инструментом для решения задач оптимизации, в которых стандартные методы недостаточно эффективны из-за наличия множества локальных минимумов. Благодаря своей способности к глобальному поиску и умению избегать застревания в локальных решениях, алгоритм находит широкое применение в различных областях, от логистики и сетевого планирования до биоинформатики и финансов.



#bibliography("/authors.bib", style: "/gost-r-7-0-5-2008-numeric-alphabetical.csl", title: "Список использованных источников", full: true)

#appendix()

==== Код реализации метода имитации отжига в задаче коммивояжёра на языке Python

#simple-code(raw(read("/include/generate.py")),
             "Код файла generate.py",
             label: <otzhig-gen>)

#simple-code(raw(read("/include/backup_10.csv")),
             "Код файла data.csv",
             label: <otzhig-data>)

#simple-code(raw(read("/include/non_weight.py")),
             "Код файла main.py",
             label: <otzhig>)


==== Код реализации метода имитации отжига в задаче оптимизации функции на языке Python

#simple-code(raw(read("/include/glob_min.py")),
             "Реализация метода имитации отжига",
             label: <cauchy-code>)