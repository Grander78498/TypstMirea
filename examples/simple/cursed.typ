#import ("/src/titul.typ"): *
#import ("/src/preamble.typ"): *
#set page(margin: (top: 0pt, bottom: 0pt, left: 0pt, right: 0pt))
#figure(image("/img/cursed_titul1.png", height: 100%), caption: none)
#figure(image("/img/cursed_titul2.png", height: 100%), caption: none)
#figure(image("/img/cursed_titul3.png", height: 100%), caption: none)
#show: main

#show: template

#outline()

#heading("Введение", numbering: none)
В современном мире, где объем информации стремительно растет, а системы поддержки принятия решений становятся неотъемлемой частью деятельности организаций и предприятий, возникает необходимость в эффективных методах анализа данных и оптимизации процессов.

Системный анализ данных является ключевым направлением, объединяющим гуманитарные и формальные методы познания. Современные подходы в этой области опираются на интеграцию концепций философии, математики и кибернетики, позволяя моделировать сложные системы и анализировать их поведение. Одним из таких инструментов является использование онтологий --- представлений о моделях мира, которые обеспечивают структуризацию информации, упрощая её анализ и обработку.

В рамках данной курсовой работы была поставлена задача разработки и реализации онтологии "Музыкальная индустрия", а также исследования и применения различных алгоритмов оптимизации для решения задач в этой области. Онтология "Музыкальная индустрия" представляет собой структурированное описание ключевых понятий и отношений в музыкальной индустрии, что позволяет более эффективно анализировать и обрабатывать данные, связанные с этой сферой.

Вместе с онтологиями в системах анализа данных и поддержки принятия решений активно применяются алгоритмы оптимизации, такие как имитация отжига, алгоритм роя частиц, муравьиный, пчелиный и электромагнитный алгоритмы. Эти методы основаны на принципах самоорганизации и коллективного поведения, которые наблюдаются в природе. Использование таких подходов позволяет моделировать сложные системы и находить оптимальные решения в многомерных пространствах.


//
// ОНТОЛОГИЯ
// 

= Онтология
Возникновение онтологий и их стремительное развитие связано с проявлением в нашей реальности следующих новых факторов: 
- колоссальный рост объемов информации, предъявляемых для обработки (анализа, использования) специалистам самых различных областей деятельности
- чрезвычайная зашумленность этих потоков (повторы, противоречивость, разноуровневость, и т.п.)
- острая необходимость в использовании одних и тех же знаний разными специалистами в разных целях
- всеобщая интернетизация нашей жизни и острая необходимость в структуризации информации для её представления пользователям и более эффективного поиска
- необходимость сокращения времени на поиск нужной информации и повышения качества информационных услуг в Интернете

Онтологии –-- это базы знаний специального типа, которые могут читаться и пониматься, отчуждаться от разработчика и/или физически разделяться их пользователями.

Существует много видов онтологий, однако одним из самых широко применяемых видов являются онтологии предметных областей, содержащие понятия определённой области знаний или входящих в неё областей.
Формальная модель онтологии представлена следующей формулой:
#eq-simple($ O = < X, R, F> " ,"$)

#print_symbols(
[$X$ --- конечное множество концептов (понятий, терминов) предметной области, которую представляет онтология],
[$R$ --- конечное множество отношений между концептами (понятиями, терминами) заданной предметной области],
[$F$ --- конечное множество функций интерпретации (аксиоматизации), заданных на концептах и/или отношениях онтологии]
)

Существует много видов онтологий, однако одним из самых широко применяемых видов являются онтологии предметных областей, содержащие понятия определённой области знаний или входящих в неё областей.

== Постановка задачи
Необходимо разработать онтологию выбранной предметной области --- "Музыкальная индустрия". Данная предметная область выбрана в связи с тем, что в современном мире прослушивание музыки стало очень доступным с использованием стриминговых сервисов, и поэтому есть острая необходимость в систематизации музыки, чтобы её было доступно выкладывать в Интернет @Sorokin.
== Описание онтологии
Основным продуктом звукозаписывающих компаний являются музыкальные записи --- наиболее распространёнными из них являются песни и альбомы, являющиеся сборниками песен. Авторами альбомов выступают либо группы, либо отдельные музыканты, и обе эти категории также связаны между собой –-- группы состоят из музыкантов @Karpenko.

На основе этого описания можно составить онтологию, состоящую из следующих классов:
- "Музыкальная индустрия" — общий базовый класс для всех классов
- "Музыкальная запись" — базовый класс для разных видов музыкальных записей, содержит общий слот "Название"
- "Альбом" — класс для описания альбомов, содержит слоты "Год выхода" и "Исполнитель", ссылающийся на экземпляр класса "Исполнитель"
- "Песня" — класс для описания песен, содержит слот "Входит в альбом", ссылающийся на экземпляр класса "Альбом"
- "Исполнитель" — базовый класс для всех видов исполнителей, содержит общие слоты "Имя" и "Страна происхождения"
- "Группа" — класс для описания групп, не содержит своих слотов
- "Музыкант" — класс для описания музыкантов, содержит слот "Входит в группу", ссылающийся на экземпляр класса "Группа"
Данное описание использовано для построения графической схемы онтологии (Рисунок @ont-schema).
#figure(image("/img/main1_ont_schema.png"), caption: [Схема онтологии "Музыкальная индустрия"])<ont-schema>

== Построение онтологии в Protégé
Для подробного изучения составленной онтологии использован инструмент для построения, редактирования онтологий и работы с ними Protégé. Сначала созданы классы, представленные на Рисунке @class-hier.

#figure(image("/img/main1_class.png"), caption: [Составленная иерархия классов])<class-hier>

На Рисунке @album-class представлены слоты класса "Альбом". Слотами данного класса являются: название альбома, исполнитель и год выпуска.

#figure(image("/img/main1_album.png"), caption: [Слоты класса "Альбом"])<album-class>

На Рисунке @song-class представлены слоты класса "Песня". Слотами данного класса являются: альбом и название.

#figure(image("/img/main1_song.png"), caption: [Слоты класса "Песня"])<song-class>

На Рисунке @musician-class представлены слоты класса "Музыкант". Слотами данного класса являются: страна происхождения, группа и имя.

#figure(image("/img/main1_musician.png", height: 13%), caption: [Cлоты класса "Музыкант"])<musician-class>

На Рисунке @group-class представлены слоты класса "Группа". Слотами данного класса являются страна и название.

#figure(image("/img/main1_group.png"), caption: [Слоты класса "Группа"])<group-class>

После составления и описания классов созданы экземпляры каждого из классов. На Рисунке @group-ex представлены экземпляры класса "Группа" и значения полей в одном из них.

#figure(image("/img/main1_group_ex.png"), caption: [Экземпляры класса "Группа"])<group-ex>

На Рисунке @musician-ex представлены экземпляры класса "Музыкант" и значения полей в одном из них.
 
#figure(image("/img/main1_musician_ex.png"), caption: [Экземпляры класса "Музыкант"])<musician-ex>

На Рисунке @song-ex представлены экземпляры класса "Песня" и значения полей в одном из них.
 
#figure(image("/img/main1_song-ex.png"), caption: [Экземпляры класса "Песня"])<song-ex>

На Рисунке @album-ex представлены экземпляры класса "Альбом" и значения полей в одном из них.
 
#figure(image("/img/main1_album-ex.png"), caption: [Экземпляры класса "Альбом"])<album-ex>

== Выполнение запросов в Protege
Программа Protégé позволяет составлять запросы на получение объектов по определённым условиям, а также вытаскивать связанные объекты для уже полученных объектов. Проделан обычный запрос на получение экземпляров (Рисунок @simple).

#figure(image("/img/main1_simple.png"), caption: [Одинарный запрос на получение песен из альбома])<simple>
 
На Рисунке @chained представлен цепной запрос на получение песен, написанных одной группой.

#figure(image("/img/main1_chained.png", height: 20%), caption: [Цепной запрос на получение песен, написанных одной группой])<chained>

На Рисунке @chained1 представлен цепной запрос на получение песен, написанных одним музыкантом.

#figure(image("/img/main1_chained1.png"), caption: [Цепной запрос на получение песен, написанных одним музыкантом])<chained1>
 
== Результаты выполнения программного кода
Для работы с онтологиями написана программа на языке Python, которая запускается в консоли и поддерживает выполнение запросов на получение экземпляров. Её код представлен в Листинге @ont. На Рисунке @ont-result1 представлен результат выполнения запроса музыкантов в группе, выполненный в программе.

#figure(image("/img/main1_result1.png"), caption: [Результат выполнения программы])<ont-result1>

На Рисунке @ont-result2 представлен результат получения песен, написанных группой, с помощью запроса, выполненного в программе.

#figure(image("/img/main1_result2.png"), caption: [Результат выполнения программы])<ont-result2>

== Выводы по разделу
В ходе выполнения данной практической работы изучены теоретические основы системного анализа и использования онтологий в широком ряде задач, получены навыки построения онтологий и работы с ними, включая создание классов для описания выбранной предметной области, создание слотов в классах и создание экземпляров. С помощью инструменты работы с онтологиями Protégé выполнены запросы на получение объектов по различным запросам.

В качестве закрепления полученных знаний написана программа на языке Python, способная работать с онтологией выбранной предметной области. В её функционал входит возможность писать запросы на получение экземпляров и связанных объектов.


//
// МЕТОД ИМИТАЦИИ ОТЖИГА
// 

= Метод имитации отжига
Метод имитации отжига — это алгоритм оптимизации, основанный на принципах физического процесса отжига, в котором материал медленно охлаждается с целью достижения состояния минимальной энергии.

Алгоритм имитации отжига предложен в 1953 году Метрополисом (N.C. Metropolis). Данный алгоритм можно считать одним из немногих универсальных алгоритмов решения задач глобальной оптимизации.

Метод имитации отжига особенно актуален в современных условиях, когда многие задачи оптимизации стали слишком сложными для традиционных методов. С увеличением объёма данных и усложнением систем возникает необходимость в алгоритмах, способных находить решения в условиях высокой размерности и множества локальных минимумов. Имитация отжига предоставляет эффективный способ решения таких задач за счёт своей способности преодолевать локальные оптимумы и исследовать глобальные решения, что делает метод востребованным в разнообразных отраслях.

Метод имитации отжига находит широкое применение в таких сферах, как логистика и транспорт (например, для решения задач маршрутизации и оптимизации цепей поставок), телекоммуникации (для оптимизации сетевых ресурсов), экономика (для моделирования и оптимизации портфелей инвестиций), проектирование сложных инженерных систем (например, для оптимального размещения элементов на печатных платах), а также в биоинформатике и химии (для решения задач структурной биологии и моделирования молекул).
== Описание алгоритма
Алгоритм имитации отжига состоит из следующих шагов:

+ Задание начальных параметров --- выбор случайного начального решения и заданного значения температуры.
+ Генерация нового решения в окрестности текущего и оценка его качества.
+ Если новое решение лучше текущего, то алгоритм переходит к нему. Если нет, то переход всё равно может быть выполнен с некоторой вероятностью, зависящей от температуры и разности в качестве решений (@prob).

$ h(X, T) = cases(1 ", если " f(X') - f(X) < 0, e^(-frac(Delta E, T)) ", если " f(X') - f(X) >= 0) $<prob>

4. После этого шага температура снижается по заданному закону, и происходит переход к шагу 2.
5. Точкой останова алгоритма является достижение температурой определённого порога.

== Постановка задачи
Цель работы: реализовать метод имитации отжига для решения задачи коммивояжёра и нахождения оптимального значения функции.

Поставлены следующие задачи:
- изучить метод имитации отжига
- выбрать предметную область для задачи коммивояжёра и функцию для оптимизации
- расписать ручной расчёт двух итераций в каждой из задач
- разработать программный код решения задач методом имитации отжига

Условие задачи коммивояжёра: дан полный граф, т.е. из каждой вершины можно пройти в любую другую вершину. В этом графе нужно найти полный путь минимальной длины, т.е. обойти каждую вершину в графе по одному разу.

Нахождение глобального минимума функции от многих переменных состоит в поиске точки в многомерном пространстве, где значение функции будет минимальным. Сложность этой задачи состоит в том, что функция может содержать множество локальных минимумов, где производная функция равна нулю, но значение функции не является минимальным.

Выбранная предметная область для задачи коммивояжёра: в торговом центре расположено n магазинов. Человеку нужно пройтись по всем этим магазинам, при этом ему нужно затратить как можно меньше усилий на это, т.е. общий пройденный путь должен быть минимально возможным. Поэтому нужно определить минимальный путь, позволяющий обойти все магазины.

Выбранная функция для оптимизации: функция Растригина (@rastrigin). Она примечательна тем, что имеет большое количество локальных минимумов. Глобальный минимум функции достигается в точке $(0;0)$ и равен 0, при этом, в остальных локальных минимумах значение функции больше нуля. Функция рассматривается на области $x_i in [-5.12, 5.12]$.

$ f(x, y) = 20 + x^2 - 10 cos(2pi x) + y^2 - 10cos(2pi y) $<rastrigin>
#v(-18pt)

== Задача коммивояжёра
=== Математическая модель
Для ручного расчёта число магазинов в задаче взято равным 6. Для каждого магазина случайным образом сгенерированы координаты в двумерном пространстве (диапазон координат от -10 до 10). Эти данные представлены заданы в Таблице @store.

#let data = csv("/include/backup_6.csv")
#simple-table(columns: 3,
              name: "Характеристики магазинов",
              header: ([Номер магазина], [Координата по x], [Координата по y]), 
              label: <store>, 
              ..data.slice(1, data.len()).flatten())

Важно, что у дома нулевые координаты.

Для расчёта расстояний между вершинами в графе использовалось Евклидово расстояние для точек в двумерном пространстве (@euclid).

$ d = sqrt((x_2 - x_1)^2 - (y_2 - y_1)^2) $<euclid>

Ниже приведены расчёты длины каждого ребра в графе, т.е. рассчитаны длины путей между каждой парой вершин.

#eq-simple($ sqrt((92 + 67)^2 + (-97 - 28)^2) = 202.25 \
sqrt((92 + 14)^2 + (-97 + 90)^2) = 106.23 \
sqrt((92 + 67)^2 + (-97 - 72)^2) = 232.04 \
sqrt((92 - 19)^2 + (-97 - 75)^2) = 186.85 \
sqrt((92 - 77)^2 + (-97 + 97)^2) = 15.0 \
sqrt((-67 + 14)^2 + (28 + 90)^2) = 129.36 \
sqrt((-67 + 67)^2 + (28 - 72)^2) = 44.0 \
sqrt((-67 - 19)^2 + (28 - 75)^2) = 98.01 \
sqrt((-67 - 77)^2 + (28 + 97)^2) = 190.69 \
sqrt((-14 + 67)^2 + (-90 - 72)^2) = 170.45 \
sqrt((-14 - 19)^2 + (-90 - 75)^2) = 168.27 \
sqrt((-14 - 77)^2 + (-90 + 97)^2) = 91.27 \
sqrt((-67 - 19)^2 + (72 - 75)^2) = 86.05 \
sqrt((-67 - 77)^2 + (72 + 97)^2) = 222.03 \
sqrt((19 - 77)^2 + (75 + 97)^2) = 181.52 $)


Рассчитанные длины рёбер сведены в Таблицу @length с указанием вершин, составляющих ребро.
#simple-table(name: "Длины рёбер в графе",
              header: ([Ребро], [Длина ребра]), 
              label: <length>, 
              [0 #math.arrow 1], [ 202.25],
              [0 #math.arrow 2], [ 106.23],
              [0 #math.arrow 3], [ 232.04],
              [0 #math.arrow 4], [ 186.85],
              [0 #math.arrow 5], [ 15.00],
              [1 #math.arrow 2], [ 129.36],
              [1 #math.arrow 3], [ 44.00],
              [1 #math.arrow 4], [ 98.01],
              [1 #math.arrow 5], [ 190.69],
              [2 #math.arrow 3], [ 170.45],
              [2 #math.arrow 4], [ 168.27],
              [2 #math.arrow 5], [ 91.27],
              [3 #math.arrow 4], [ 86.05],
              [3 #math.arrow 5], [ 222.03],
              [4 #math.arrow 5], [ 181.52]
              )

=== Ручной расчёт
Сначала нужно составить путь случайным образом:
$0 -> 4 -> 5 -> 3 -> 2 -> 6 -> 1 -> 0$.
Длина полученного пути: $S_0 = 10.82 + 10.82 + 5.0 + 12.65 + 5.39 + 10.3 + 5.0 + 5.0 + 6.0 + 6.0 = 76.96 (м)$.

За изначальную температуру взята $T_0 = 100$.

Для первой итерации вместо четвёртого магазина поставлен пятый магазин, и после этого перестроен путь:
$0 -> 5 -> 4 -> 3 -> 2 -> 6 -> 1 -> 0$.
После этого проводится расчёт длины текущего пути: $S_1 = 5.0 + 7.81 + 15.81 + 10.3 + 8.06 + 8.06 + 10.82 + 10.82 + 5.0 + 5.0 = 86.68 (м)$.
Длина текущего пути оказалась больше длины лучшего пути, поэтому проводится расчёт вероятности перехода к текущему решению.

#eq-simple($ H = e^(-frac(Delta l, T_0)) = e^(-(86.68-76.96)/100) approx 0.378 $)

Вероятность, выданная псевдослучайным генератором чисел от 0 до 1, равна 0.363, что меньше 0.378. Поэтому текущее решение принимается как лучшее.

В конце первой итерации температура уменьшается в два раза по сравнению с изначальной: $T_1 = T_0 / 2 = 100 / 2 = 50$.

Для второй итерации на место третьего магазина поставлен шестой, после чего перестроен путь:
$0 -> 5 -> 1 -> 2 -> 6 -> 3 -> 4 -> 0$.

Длина получившегося пути равна $S_2 = 5.0 + 7.81 + 15.81 + 10.3 + 5.0 + 7.62 + 8.06 + 10.82 + 10.82 = 81.23 (м)$.

Длина получившегося пути меньше длины лучшего пути, поэтому текущее решение сразу принимается.

В конце второй итерации температура уменьшается в два раза по сравнению с температурой на текущей итерации: $T_2 = T_1 / 2 = 50 / 2 = 25$.

== Поиск глобального минимума
Выбранная функция: функция Растригина от двух переменных. Её формула представлена формулой @rastrigin.

На Рисунке @rastr-im представлен график этой функции.

#figure(image("/img/main2_rastrigin.png", height: 30%), caption: [График функции Растригина])<rastr-im>

Координаты начальной точки сгенерированы случайным образом и равны (2.75, 3.17). Значение функции в этой точке равно 32.53.

На первой итерации температура равна $T_0 = 100$.

Текущее решение на каждой итерации генерируется с использованием распределения Коши (@cauchy), где $D = 2$, т.к. задача рассматривается в двумерном пространстве.

$ g(x, x', T) = 1 / pi^D product_(i = 1)^D T / (abs(x' - x)^2 + T^2) $<cauchy>

Текущее решение на первой итерации: (4.7, 5). Значение функции в этой точке равно 60.18.

Поскольку текущее решение оказалось хуже лучшего, то проводится расчёт вероятности перехода к этому решению.

#eq-simple($ H=e^(-(Delta f) / T_0 ) = e^(-(60.18-32.53)/100) approx 0.758 $)

Вероятность, выданная псевдослучайным генератором чисел от 0 до 1, равна 0.923, что больше 0.758. Поэтому текущее решение отбрасывается. Лучшее решение после первой итерации: (2.75, 3.17), значение функции: 32.53.

После выполнения первой итерации температура изменена в соответствии с законом Коши.

#eq-simple($ T_1 = T_0 / k^(1/D) = 100 / 1^(1/2) = 100 $)

При переходе на вторую итерацию текущим решением выбрано: (1.23, 1.35). Значение функции в этой точке равно 27.96.

Текущее решение оказалось оптимальнее лучшего, поэтому оно автоматически принимается. Лучшее решение после второй итерации: (1.23, 1.35), значение функции: 27.96.

После выполнения второй итерации температура изменена в соответствии с законом Коши.

#eq-simple($ T_2 = T_0 / k^(1/D) = 100 / 2^(1/2) approx 70,711 $)

== Программная реализация
Для реализации расчётов метода имитации отжига написан программный код на языке Python.

В программной реализации задачи коммивояжёра зафиксированы следующие параметры:
- количество магазинов: 10
- диапазон координат магазинов: $[-100; 100]$

Код, реализующий решение поставленной задачи коммивояжёра методом имитации отжига, представлен в Листинге @otzhig-gen. Код, отвечающий за генерацию данных для задачи, представлен в Листинге @otzhig-data, а сгенерированные данные представлены в Листинге @otzhig.

На Рисунке @otzh-path представлен результат выполнения программы, решающей задачу коммивояжёра --- построенный граф после завершения алгоритма. Вертикальная и горизонтальная оси являются координатными осями.

#figure(image("/img/main2_otzh-path.png", height: 35%), caption: [Построенный минимальный путь в графе])<otzh-path>

На Рисунке @otzh-graph представлен график, отражающий изменение длины пути в графе в течение выполнения итераций алгоритма.

#figure(image("/img/main2_otzh-graph.png"), caption: [График изменения длины пути])<otzh-graph>
 
Код реализации имитации отжига методом Коши для нахождения оптимального значения функции представлен в Листинге @cauchy-code.

На Рисунке @cauchy-res представлен результат выполнения программы для нахождения оптимального значения функции --- график зависимости оптимального решения от номера итерации.

#figure(image("/img/main2_cauchy-res.png"), caption: [График зависимости оптимального значения функции от номера итерации])<cauchy-res>

== Выводы по разделу
В ходе выполнения данной работы выполнены поставленные задачи – изучен метод имитации отжига, произведён его ручной расчёт для решения задачи коммивояжера и задачи поиска глобального минимума функции, а также разработаны программы на языке Python для решения поставленной задачи коммивояжёра – обхода всех магазинов, и для нахождения глобального минимума функции Растригина от двух переменных.

В заключение можно отметить, что метод имитации отжига является мощным инструментом для решения задач оптимизации, в которых стандартные методы недостаточно эффективны из-за наличия множества локальных минимумов. Благодаря своей способности к глобальному поиску и умению избегать застревания в локальных решениях, алгоритм находит широкое применение в различных областях, от логистики и сетевого планирования до биоинформатики и финансов.


//
// АЛГОРИТМ РОЯ ЧАСТИЦ
// 

= Алгоритм роя частиц
В основу алгоритма оптимизации роем частиц положена социально-психологическая поведенческая модель толпы. Развитие алгоритма инспирировали такие задачи, как моделирование поведения птиц в стае и рыб в косяке. Целью было обнаружить базовые принципы, благодаря которым, например, птицы в стае ведут себя удивительно синхронно, меняя как по команде направления своего движения, так что стая движется как единое целое. К современному времени концепция алгоритма роя частиц развилась в высокоэффективный алгоритм оптимизации, часто составляющий конкуренцию лучшим модификациям генетического алгоритма.

В настоящее время роевой алгоритм применяются при решении задач численной и комбинаторной оптимизации, обучении искусственных нейронных сетей, построении нечетких контроллеров и т.д. в различных областях науки техники:

-	управление энергетическими системами
-	решение NP-трудных комбинаторных проблем
-	задачи календарного планирования
-	оптимизация в мобильной связи
-	оптимизация процессов пакетной обработки
-	оптимизация многокритериальных задач
-	обработка изображений; распознавание образов
-	кластеризация данных
-	биоинформатика
-	проектирование сложных технических систем и т.д


== Описание алгоритма
Сначала происходит инициализация начальных параметров и роя --- генерация точек в области поиска (количество точек задано и равно S), а также свободных параметров алгоритма. Каждая точка имеет координаты и вектор скорости (@swarm-coord).

$ x_k = (x_1^k, x_2^k, dots, x_n^k); v_k = (v_1^k, v_2^k, dots, v_n^k), $<swarm-coord>

#print_symbols(($k$, [номер частицы]),
               ($n$, [размерность векторов в задаче]))

Далее происходит поиск лучшего решения для каждой частицы, после которого обновляется лучшее решение для всего роя, если какой-то частицей найдено решение, которое лучше текущего.
Затем выполняется коррекция скорости для каждой частицы по Формуле @swarm-speed.

$ v_i (t+1)=v_i (t)+c_1 r_1 (t)(y_i (t)-x_i (t))+c_2 r_2 (t)(y ̂(t)-x_i (t)), $<swarm-speed>

#print_symbols(($c_1,c_2$, [положительные коэффициенты ускорения]),
                ($r_1 (t),r_2 (t)$, [вектора размерности $n$, состоящие из случайных чисел из диапазона $(0; 1)$; при этом, $r_2 (t)=1-r_1 (t)$]),
                ($y_i (t)$, [позиция i-й частицы, где достигалось лучшее решение]),
                ($y (t)$, [координаты частицы с лучшим решением всего роя]))

После этого выполняется коррекция позиции каждой частицы по Формуле @correct-pos.

$ x_i (t+1)=x_i (t)+v_i (t+1) $<correct-pos>

Точкой останова алгоритма является выполнение заданного числа итераций.

== Постановка задачи

Цель работы: реализовать глобальный алгоритм роя частиц для нахождения оптимального значения функции.

Поставлены следующие задачи:

- изучить алгоритм роя частиц
- выбрать тестовую функцию для оптимизации (нахождение глобального минимума)
- произвести ручной расчёт двух итераций алгоритма для трёх частиц
- разработать программную реализацию алгоритма роя частиц для задачи минимизации функции

Выбранная функция для оптимизации: функция Растригина (@rastrigin-2). Она примечательна тем, что имеет большое количество локальных минимумов. Глобальный минимум функции достигается в точке $(0;0)$ и равен 0, при этом, в остальных локальных минимумах значение функции больше нуля. Функция рассматривается на области $x_i in [-5.12,5.12]$.

$ f(x,y)=20+x^2-10 cos(2 pi x)+y^2-10 cos(2 pi y) $<rastrigin-2>

== Ручной расчёт алгоритма

Выбранная функция: функция Растригина от двух переменных. Её формула представлена Формулой @rastrigin-2.
На Рисунке @rastrigin-im-2 представлен график этой функции.

#figure(image("/img/prac3_rastrigin.png"), caption: [График функции Растригина])<rastrigin-im-2>

Инициализированы свободные параметры алгоритма:

- $c_1=c_2=2$
- количество частиц: 3
Далее созданы три частицы со следующими характеристиками:

#eq-simple($x_1=(0.2,3.5);v_1=(0,0)\
x_2=(1.3,0.98);v_2=(0,0)\
x_3=(4.87,-3.1);v_3=(0,0)$)

Значение целевой функции в первой точке равно 39.2; значение целевой функции у второй частицы равно 15.82; значение целевой функции у третьей частицы равно 38.39.

Лучшая позиция у каждой частицы пока что считается равной текущей позиции каждой частицы, а лучшая позиция всего роя --- у второй частицы.

Затем выполняется коррекция скорости по Формуле @swarm-speed. Для коррекции скорости первой частицы сгенерирован двумерный вектор из случайных чисел $r_1=(0.234,0.567)$.

#eq-simple($v_11 (1)=0+2*0.234*(0.2-0.2)+2*(1-0.234)*(1.3-0.2)=1.685 \
v_12 (1)=0+2*0.567*(3.5-3.5)+2*(1-0.567)*(0.98-3.5)=-2.182$)

Для коррекции скорости второй частицы сгенерирован двумерный вектор из случайных чисел $r_2=(0.123,0.987)$.

#eq-simple($v_21 (1)=0+2*0.123*(1.3-1.3)+2*(1-0.123)*(1.3-1.3)=0\
v_22 (1)=0+2*0.987*(0.98-0.98)+2*(1-0.987)*(0.98-0.98)=0$)

Для коррекции скорости третьей частицы сгенерирован двумерный вектор  из случайных чисел $r_2=(0.555,0.002)$.

#eq-simple($v_31 (1)=0+2*0.555*(4.87-4.87)+2*(1-0.555)(1.3-4.87)=-3.177\
v_32 (1)=0+2*0.002*(-3.1+3.1)+2*(1-0.002)*(0.98+3.1)=8.144$)

После коррекции скоростей выполняется коррекция координат каждой из частиц:

#eq-simple($x_11 (1)=0.2+1.685=1.885\
x_12 (1)=3.5-2.182=1.318\
x_21 (1)=1.3+0=1.3\
x_22 (1)=0.98+0=0.98\
x_31 (1)=4.87-3.177=1.693\
x_32 (1)=-3.1+8.144=5.044$)

После этого происходит переход ко второй итерации. Заново рассчитаны значения функции у каждой частицы:

#eq-simple($f_1 (1)=21.93\
f_2 (1)=15.82\
f_3 (1)=42.19$)

Значение целевой функции у первой частицы улучшилось, поэтому лучшая позиция теперь $(1.885, 1.318)$. Значение целевой функции у второй частицы не изменилось, поэтому её лучшая позиция осталась $(1.3, 0.98)$. Значение целевой функции у третьей частицы ухудшилось, поэтому лучшая позиция у третьей частицы остаётся как была изначально: $(4.87, -3.1)$. Лучшая позиция всего роя остаётся у второй частицы.

Затем выполняется коррекция скорости по Формуле @swarm-speed. Для коррекции скорости первой частицы сгенерирован двумерный вектор из случайных чисел $r_1=(0.124,0.5)$.

#eq-simple($v_11 (2) = 1.685 + 2 * 0.124 * (1.885 - 1.885) &+ \
           + 2 * (1-0.124)*(1.3-1.885)&=0.66\
          v_12 (2)=0+2*0.5*(1.318-1.318)&+\ 
          +2*(1-0.5)*(0.98-1.318)&=-0.33$)

Для коррекции скорости второй частицы сгенерирован двумерный вектор из случайных чисел $r_2=(0.01,0.8)$.

#eq-simple($v_21 (2)=0+2*0.01*(1.3-1.3)+2*(1-0.01)*(1.3-1.3)=0\
v_22 (2)=0+2*0.8*(0.98-0.98)+2*(1-0.8)*(0.98-0.98)=0$)

Для коррекции скорости третьей частицы сгенерирован двумерный вектор  из случайных чисел $r_3=(0.4,0.8)$.

#eq-simple($v_31 (2)=0+2*0.4*(4.87-1.693)+2*(1-0.4)*(1.3-1.693)=2.07\
v_32 (2)=0+2*0.8*(-3.1-5.044)+2*(1-0.8)*(0.98-5.044)=-14.656$)

После коррекции скоростей выполняется коррекция координат каждой из частиц:

#eq-simple($x_11 (1)=1.885+0.66=2.545\
x_12 (1)=1.318-0.33=0.988\
x_21 (1)=1.3+0=1.3\
x_22 (1)=0.98+0=0.98\
x_31 (1)=1.693+2.07=3.763\
x_32 (1)=5.044-14.656=-9.612$)

Но координата $x_32$ получилась вне области поиска, поэтому она принимается равной -5.12, т.е. позиция третьей частицы: $(3.763, -5.12)$.
Заново рассчитаны значения функции у каждой частицы:

#eq-simple($f_1 (2)=27.08\
f_2 (2)=15.82\
f_3 (2)=52.27$)

== Программная реализация

Для реализации расчётов алгоритма роя частиц написан программный код на языке Python.

В программной реализации зафиксированы следующие параметры:

-	количество частиц: 20
-	количество итераций: 30
-	$c_1$ и $c_2$: 2

Код реализации роевого алгоритма для нахождения оптимального значения функции представлен в Листинге @swarm-code.

На Рисунке @swarm-res представлен результат выполнения программы для нахождения оптимального значения функции --- график зависимости оптимального решения от номера итерации. 

#figure(image("/img/prac3_swarm-res.png"), caption: [График зависимости оптимального значения функции от номера итерации])<swarm-res>

== Выводы по разделу
В ходе выполнения данной работы выполнены поставленные задачи --- изучен алгоритм роя частиц, произведён его ручной расчёт для решения задачи поиска глобального минимума функции, а также разработаны программы на языке Python для нахождения глобального минимума функции Растригина от двух переменных.

В заключение можно отметить, что роевой алгоритм является мощным инструментом для решения задач оптимизации, в которых стандартные методы недостаточно эффективны из-за наличия множества локальных минимумов. При этом, алгоритм является простым в реализации и имеет мало свободных параметров, из-за чего алгоритм не нуждается в длительной метаоптимизации.

//
// МУРАВЬИНЫЙ АЛГОРИТМ
// 

= Муравьиный алгоритм
Муравьиный алгоритм --- это эвристический метод оптимизации, разработанный итальянским ученым Марко Дориго в 1992 году. Работа алгоритма вдохновлена тем, как колония муравьев отправляется на поиски пищи. Каждый муравей оставляет на своем пути феромоны --- химические вещества, привлекающие других муравьев. Чем больше муравьев проходит по определенному пути, тем сильнее концентрация феромонов на нем. В результате, большинство муравьев выбирает путь с наибольшей концентрацией феромонов, который, как правило, является кратчайшим.

Муравьиный алгоритм моделирует это поведение. Вместо реальных муравьев и феромонов, алгоритм использует "искусственных муравьев" и "искусственные феромоны".

Искусственные муравьи перемещаются по графу, представляющему пространство поиска, и оставляют феромоны на ребрах, которые они посещают. Вероятность выбора муравьем определенного ребра зависит от концентрации феромонов на нем и других факторов, таких как расстояние. Со временем, феромоны испаряются, что позволяет алгоритму "забывать" неудачные пути и сосредотачиваться на наиболее перспективных.

Муравьиный алгоритм широко используется для решения различных задач оптимизации, таких как:

-	задача коммивояжера: поиск кратчайшего маршрута, проходящего через все заданные города
-	распределение ресурсов: оптимальное распределение ресурсов (например, рабочей силы, оборудования) для выполнения задач
-	планирование: составление расписаний, оптимизация маршрутов транспорта
-	сетевое проектирование: поиск оптимальных путей в сетях (например, компьютерных, транспортных)

== Описание алгоритма
Сначала происходит инициализация начальных параметров и самой муравьиной колонии --- для алгоритма муравьи создаются в количестве, равном количеству вершин в графе, и каждый из них начинает свой путь со своей вершины.

Важно отметить, что на каждую дугу графа «наносят» феромон --- число, сгенерированное псевдослучайным образом в интервале от 0 до 1. Оно является одинаковым для всех дуг перед начальной итерацией.

Далее происходит построение пути для каждого муравья в колонии. Выбор муравьём новой вершины определяется с помощью вероятности, определяемой по Формуле @ant-prob.

$ p_(i j)^k = cases(
  (tau_(i j)^alpha (t) eta_(i j)^beta (t)) / (sum_(u in N_i^k) t_(i u)^alpha (t) eta_(i u)^beta (t)) &", если " j in N_i^k,
  0 &", если " j cancel(in) N_i^k
)"  ," $ <ant-prob>

#print_symbols(($i$, [номер текущей вершины муравья]),
	            ($j$, [номер вершины, куда муравей может перейти]),
              ($τ_(i j)$, [количество феромона на дуге]),
	            ($η_(i j)$, [априорная эффективность перехода по дуге из i в j]),
              ($N_i^k$, [множество доступных вершин для перемещения]),
	            ($alpha, beta$, [свободные параметры алгоритма (вес фермента и коэффициент эвристики)]))
После построения пути для каждого муравья высчитывается длина его пути.
Далее на каждой дуге происходит испарение феромона (@pher-vapor).

$ tau_(i j) (t)=(1-rho) tau_(i j) (t) " ," $<pher-vapor>

#print_symbols(
  ($rho$, [коэффициент испарения, $rho in [0,1]$])
)

Для каждой дуги происходит изменение феромона в зависимости от того, насколько оптимальный путь получился у муравьёв (@pher-update).

$ tau_(i j) (t + 1) = t_(i j) (t) + sum_(k=1)^(n_k) Delta tau_(i j) (t) $<pher-update>

#print_symbols(
  (v(12pt) + eq-simple($ Delta tau_(i j)^k (t) = cases(
    Q / L^k (t) &", если дуга " (i, j) " есть в пути " x^k (t),
    0 &", иначе"
  ) "  " dash.em$), [изменение количества феромона в зависимости от длины пройденного пути]),
  ($Q$, [положительная константа])
)
Точкой останова алгоритма является выполнение заданного числа итераций.
== Постановка задачи
Цель работы: реализовать задачу коммивояжера муравьиным алгоритмом для нахождения приближённого оптимального маршрута.

Поставлены следующие задачи:
- изучить муравьиный алгоритм
- выбрать предметную область для задачи коммивояжера
- произвести ручной расчёт одной итерации алгоритма для двух муравьёв
- разработать программную реализацию муравьиного алгоритма для задачи коммивояжера
Условие задачи коммивояжёра: дан полный граф, т.е. из каждой вершины можно пройти в любую другую вершину. В этом графе нужно найти полный путь минимальной длины, т.е. обойти каждую вершину в графе по одному разу.

Выбранная предметная область для задачи коммивояжёра: в торговом центре расположено n магазинов. Человеку нужно пройтись по всем этим магазинам, при этом ему нужно затратить как можно меньше усилий на это, т.е. общий пройденный путь должен быть минимально возможным. Поэтому нужно определить минимальный путь, позволяющий обойти все магазины.

== Ручной расчёт алгоритма
Для ручного расчёта число магазинов в задаче взято равным 6, число муравьёв --- 2. Значения свободных параметров: $alpha = 1, beta = 5, rho = 0.5$.

Для каждого магазина случайным образом сгенерированы координаты в двумерном пространстве (диапазон координат от -10 до 10). Эти данные представлены заданы в Таблице @ant-store.

#let data = csv("/include/backup_6.csv")
#simple-table(columns: 3,
              name: "Характеристики магазинов",
              header: ([Номер магазина], [Координата по x], [Координата по y]), 
              label: <ant-store>, 
              ..data.slice(1, data.len()).flatten())

Для расчёта расстояний между вершинами в графе использовалось Евклидово расстояние для точек в двумерном пространстве (@ant-euclid).

$ d = sqrt((x_2 - x_1)^2 - (y_2 - y_1)^2) $<ant-euclid>

Ниже приведены расчёты длины каждого ребра в графе, т.е. рассчитаны длины путей между каждой парой вершин.

#eq-simple($ sqrt((92 + 67)^2 + (-97 - 28)^2) = 202.25 \
sqrt((92 + 14)^2 + (-97 + 90)^2) = 106.23 \
sqrt((92 + 67)^2 + (-97 - 72)^2) = 232.04 \
sqrt((92 - 19)^2 + (-97 - 75)^2) = 186.85 \
sqrt((92 - 77)^2 + (-97 + 97)^2) = 15.0 \
sqrt((-67 + 14)^2 + (28 + 90)^2) = 129.36 \
sqrt((-67 + 67)^2 + (28 - 72)^2) = 44.0 \
sqrt((-67 - 19)^2 + (28 - 75)^2) = 98.01 \
sqrt((-67 - 77)^2 + (28 + 97)^2) = 190.69 \
sqrt((-14 + 67)^2 + (-90 - 72)^2) = 170.45 \
sqrt((-14 - 19)^2 + (-90 - 75)^2) = 168.27 \
sqrt((-14 - 77)^2 + (-90 + 97)^2) = 91.27 \
sqrt((-67 - 19)^2 + (72 - 75)^2) = 86.05 \
sqrt((-67 - 77)^2 + (72 + 97)^2) = 222.03 \
sqrt((19 - 77)^2 + (75 + 97)^2) = 181.52 $)


Рассчитанные длины рёбер сведены в Таблицу @ant-length с указанием вершин, составляющих ребро.
#simple-table(name: "Длины рёбер в графе",
              header: ([Ребро], [Длина ребра]), 
              label: <ant-length>, 
              [0 #math.arrow 1], [ 202.25],
              [0 #math.arrow 2], [ 106.23],
              [0 #math.arrow 3], [ 232.04],
              [0 #math.arrow 4], [ 186.85],
              [0 #math.arrow 5], [ 15.00],
              [1 #math.arrow 2], [ 129.36],
              [1 #math.arrow 3], [ 44.00],
              [1 #math.arrow 4], [ 98.01],
              [1 #math.arrow 5], [ 190.69],
              [2 #math.arrow 3], [ 170.45],
              [2 #math.arrow 4], [ 168.27],
              [2 #math.arrow 5], [ 91.27],
              [3 #math.arrow 4], [ 86.05],
              [3 #math.arrow 5], [ 222.03],
              [4 #math.arrow 5], [ 181.52]
              )

Также проинициализированы значения феромона на каждой дуге одним случайным значением: 0.876.

Для расчёта априорной эффективности из Формулы @ant-prob использована Формула @aprior-prob, чтобы иметь возможность проводить расчёты с точностью до пяти знаков после запятой.

$ eta_(i j)=100 / d_(i j) $<aprior-prob>

=== Первая итерация
Для упрощения расчётов муравьи начинают свой путь с первой вершины.

Далее приведены расчёты вероятностей перехода первого муравья c 1-й вершины:

#eq-simple($ p^1_12 = (0.876^1 * 0.494^2)/(0.00403) = 0.005 \
p^1_13 = (0.876^1 * 0.941^2)/(0.00403) = 0.019 \
p^1_14 = (0.876^1 * 0.431^2)/(0.00403) = 0.004 \
p^1_15 = (0.876^1 * 0.535^2)/(0.00403) = 0.006 \
p^1_16 = (0.876^1 * 6.667^2)/(0.00403) = 0.965 \
$)
Сгенерировано случайное число r = 0.783, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_2 = 0.005 < r = 0.783 \
P_3 = 0.025 < r = 0.783 \
P_4 = 0.029 < r = 0.783 \
P_5 = 0.035 < r = 0.783 \
P_6 = 1.000 >= r = 0.783 \
$)
Происходит переход на вершину 6. Далее приведены расчёты вероятностей перехода первого муравья c 6-й вершины:

#eq-simple($ p^1_62 = (0.876^1 * 0.524^2)/(0.00017) = 0.139 \
p^1_63 = (0.876^1 * 1.096^2)/(0.00017) = 0.606 \
p^1_64 = (0.876^1 * 0.450^2)/(0.00017) = 0.102 \
p^1_65 = (0.876^1 * 0.551^2)/(0.00017) = 0.153 \
$)
Сгенерировано случайное число r = 0.044, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_2 = 0.139 >= r = 0.044 \
$)
Происходит переход на вершину 2. Далее приведены расчёты вероятностей перехода первого муравья c 2-й вершины:

#eq-simple($ p^1_23 = (0.876^1 * 0.773^2)/(0.00060) = 0.088 \
p^1_24 = (0.876^1 * 2.273^2)/(0.00060) = 0.759 \
p^1_25 = (0.876^1 * 1.020^2)/(0.00060) = 0.153 \
$)
Сгенерировано случайное число r = 0.674, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_3 = 0.088 < r = 0.674 \
P_4 = 0.847 >= r = 0.674 \
$)
Происходит переход на вершину 4. Далее приведены расчёты вероятностей перехода первого муравья c 4-й вершины:

#eq-simple($ p^1_43 = (0.876^1 * 0.587^2)/(0.00015) = 0.203 \
p^1_45 = (0.876^1 * 1.162^2)/(0.00015) = 0.797 \
$)
Сгенерировано случайное число r = 0.994, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_3 = 0.203 < r = 0.994 \
P_5 = 1.000 >= r = 0.994 \
$)
Происходит переход на вершину 5. Далее приведены расчёты вероятностей перехода первого муравья c 5-й вершины:

#eq-simple($ p^1_53 = (0.876^1 * 0.594^2)/(0.00003) = 1.000 \
$)
Сгенерировано случайное число r = 0.545, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_3 = 1.000 >= r = 0.545 \
$)
Происходит переход на вершину 3. Затем муравей возвращается на начальную вершину, и его путь завершается. Таким образом, путь первого муравья выглядит следующим образом: $0 -> 5 -> 1 -> 3 -> 4 -> 2 -> 0$. Длина пути равна: $15.0 + 190.69 + 44.0 + 86.05 + 168.27 + 106.23 = 610.236$.

Далее приведены расчёты вероятностей перехода второго муравья c 1-й вершины:

#eq-simple($ p^2_12 = (0.876^1 * 0.494^2)/(0.00403) = 0.005 \
p^2_13 = (0.876^1 * 0.941^2)/(0.00403) = 0.019 \
p^2_14 = (0.876^1 * 0.431^2)/(0.00403) = 0.004 \
p^2_15 = (0.876^1 * 0.535^2)/(0.00403) = 0.006 \
p^2_16 = (0.876^1 * 6.667^2)/(0.00403) = 0.965 \
$)
Сгенерировано случайное число r = 0.145, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_2 = 0.005 < r = 0.145 \
P_3 = 0.025 < r = 0.145 \
P_4 = 0.029 < r = 0.145 \
P_5 = 0.035 < r = 0.145 \
P_6 = 1.000 >= r = 0.145 \
$)
Происходит переход на вершину 6. Далее приведены расчёты вероятностей перехода второго муравья c 6-й вершины:

#eq-simple($ p^2_62 = (0.876^1 * 0.524^2)/(0.00017) = 0.139 \
p^2_63 = (0.876^1 * 1.096^2)/(0.00017) = 0.606 \
p^2_64 = (0.876^1 * 0.450^2)/(0.00017) = 0.102 \
p^2_65 = (0.876^1 * 0.551^2)/(0.00017) = 0.153 \
$)
Сгенерировано случайное число r = 0.071, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_2 = 0.139 >= r = 0.071 \
$)
Происходит переход на вершину 2. Далее приведены расчёты вероятностей перехода второго муравья c 2-й вершины:

#eq-simple($ p^2_23 = (0.876^1 * 0.773^2)/(0.00060) = 0.088 \
p^2_24 = (0.876^1 * 2.273^2)/(0.00060) = 0.759 \
p^2_25 = (0.876^1 * 1.020^2)/(0.00060) = 0.153 \
$)
Сгенерировано случайное число r = 0.919, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_3 = 0.088 < r = 0.919 \
P_4 = 0.847 < r = 0.919 \
P_5 = 1.000 >= r = 0.919 \
$)
Происходит переход на вершину 5. Далее приведены расчёты вероятностей перехода второго муравья c 5-й вершины:

#eq-simple($ p^2_53 = (0.876^1 * 0.594^2)/(0.00015) = 0.207 \
p^2_54 = (0.876^1 * 1.162^2)/(0.00015) = 0.793 \
$)
Сгенерировано случайное число r = 0.548, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_3 = 0.207 < r = 0.548 \
P_4 = 1.000 >= r = 0.548 \
$)
Происходит переход на вершину 4. Далее приведены расчёты вероятностей перехода второго муравья c 4-й вершины:

#eq-simple($ p^2_43 = (0.876^1 * 0.587^2)/(0.00003) = 1.000 \
$)
Сгенерировано случайное число r = 0.265, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_3 = 1.000 >= r = 0.265 \
$)
Происходит переход на вершину 3. Затем муравей возвращается на начальную вершину, и его путь завершается. Таким образом, путь второго муравья выглядит следующим образом: $0 -> 5 -> 1 -> 4 -> 3 -> 2 -> 0$. Длина пути равна: $15.0 + 190.69 + 98.01 + 86.05 + 170.45 + 106.23 = 666.423$.

Затем выполняется испарение феромона по Формуле @pher-vapor:

#eq-simple($ tau_12 = (1 - 0.5) * 0.876 = 0.438\
tau_13 = (1 - 0.5) * 0.876 = 0.438\
tau_14 = (1 - 0.5) * 0.876 = 0.438\
tau_15 = (1 - 0.5) * 0.876 = 0.438\
dots\
tau_65 = (1 - 0.5) * 0.876 = 0.438
$)
Изменение концентрации феромона происходит по Формуле @pher-update, где значение Q принято за 100. Далее отображены только значения феромонов, которые после данной итерации изменились на ненулевую величину. 

#eq-simple($ tau_16 = 0.438 + 0.314 = 0.752 \
tau_24 = 0.438 + 0.164 = 0.602 \
tau_25 = 0.438 + 0.150 = 0.588 \
tau_31 = 0.438 + 0.314 = 0.752 \
tau_43 = 0.438 + 0.150 = 0.588 \
tau_45 = 0.438 + 0.164 = 0.602 \
tau_53 = 0.438 + 0.164 = 0.602 \
tau_54 = 0.438 + 0.150 = 0.588 \
tau_62 = 0.438 + 0.314 = 0.752 \
$)

=== Вторая итерация
Далее приведены расчёты вероятностей перехода первого муравья c 1-й вершины:

#eq-simple($ p^1_12 = (0.438^1 * 0.494^2)/(0.00341) = 0.003 \
p^1_13 = (0.438^1 * 0.941^2)/(0.00341) = 0.011 \
p^1_14 = (0.438^1 * 0.431^2)/(0.00341) = 0.002 \
p^1_15 = (0.438^1 * 0.535^2)/(0.00341) = 0.004 \
p^1_16 = (0.752^1 * 6.667^2)/(0.00341) = 0.979 \
$)
Сгенерировано случайное число r = 0.954, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_2 = 0.003 < r = 0.954 \
P_3 = 0.015 < r = 0.954 \
P_4 = 0.017 < r = 0.954 \
P_5 = 0.021 < r = 0.954 \
P_6 = 1.000 >= r = 0.954 \
$)
Происходит переход на вершину 6. Далее приведены расчёты вероятностей перехода первого муравья c 6-й вершины:

#eq-simple($ p^1_62 = (0.752^1 * 0.524^2)/(0.00010) = 0.217 \
p^1_63 = (0.438^1 * 1.096^2)/(0.00010) = 0.551 \
p^1_64 = (0.438^1 * 0.450^2)/(0.00010) = 0.093 \
p^1_65 = (0.438^1 * 0.551^2)/(0.00010) = 0.139 \
$)
Сгенерировано случайное число r = 0.098, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_2 = 0.217 >= r = 0.098 \
$)
Происходит переход на вершину 2. Далее приведены расчёты вероятностей перехода первого муравья c 2-й вершины:

#eq-simple($ p^1_23 = (0.438^1 * 0.773^2)/(0.00040) = 0.066 \
p^1_24 = (0.602^1 * 2.273^2)/(0.00040) = 0.781 \
p^1_25 = (0.588^1 * 1.020^2)/(0.00040) = 0.154 \
$)
Сгенерировано случайное число r = 0.065, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_3 = 0.066 >= r = 0.065 \
$)
Происходит переход на вершину 3. Далее приведены расчёты вероятностей перехода первого муравья c 3-й вершины:

#eq-simple($ p^1_34 = (0.438^1 * 0.587^2)/(0.00003) = 0.494 \
p^1_35 = (0.438^1 * 0.594^2)/(0.00003) = 0.506 \
$)
Сгенерировано случайное число r = 0.467, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_4 = 0.494 >= r = 0.467 \
$)
Происходит переход на вершину 4. Далее приведены расчёты вероятностей перехода первого муравья c 4-й вершины:

#eq-simple($ p^1_45 = (0.602^1 * 1.162^2)/(0.00008) = 1.000 \
$)
Сгенерировано случайное число r = 0.958, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_5 = 1.000 >= r = 0.958 \
$)
Происходит переход на вершину 5. Затем муравей возвращается на начальную вершину, и его путь завершается. Таким образом, путь первого муравья выглядит следующим образом: $0 -> 5 -> 1 -> 2 -> 3 -> 4 -> 0$. Длина пути равна: $15.0 + 190.69 + 129.36 + 170.45 + 86.05 + 186.85 = 778.394$.

Далее приведены расчёты вероятностей перехода второго муравья c 1-й вершины:

#eq-simple($ p^2_12 = (0.438^1 * 0.494^2)/(0.00341) = 0.003 \
p^2_13 = (0.438^1 * 0.941^2)/(0.00341) = 0.011 \
p^2_14 = (0.438^1 * 0.431^2)/(0.00341) = 0.002 \
p^2_15 = (0.438^1 * 0.535^2)/(0.00341) = 0.004 \
p^2_16 = (0.752^1 * 6.667^2)/(0.00341) = 0.979 \
$)
Сгенерировано случайное число r = 0.866, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_2 = 0.003 < r = 0.866 \
P_3 = 0.015 < r = 0.866 \
P_4 = 0.017 < r = 0.866 \
P_5 = 0.021 < r = 0.866 \
P_6 = 1.000 >= r = 0.866 \
$)
Происходит переход на вершину 6. Далее приведены расчёты вероятностей перехода второго муравья c 6-й вершины:

#eq-simple($ p^2_62 = (0.752^1 * 0.524^2)/(0.00010) = 0.217 \
p^2_63 = (0.438^1 * 1.096^2)/(0.00010) = 0.551 \
p^2_64 = (0.438^1 * 0.450^2)/(0.00010) = 0.093 \
p^2_65 = (0.438^1 * 0.551^2)/(0.00010) = 0.139 \
$)
Сгенерировано случайное число r = 0.879, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_2 = 0.217 < r = 0.879 \
P_3 = 0.768 < r = 0.879 \
P_4 = 0.861 < r = 0.879 \
P_5 = 1.000 >= r = 0.879 \
$)
Происходит переход на вершину 5. Далее приведены расчёты вероятностей перехода второго муравья c 5-й вершины:

#eq-simple($ p^2_52 = (0.438^1 * 1.020^2)/(0.00015) = 0.312 \
p^2_53 = (0.602^1 * 0.594^2)/(0.00015) = 0.145 \
p^2_54 = (0.588^1 * 1.162^2)/(0.00015) = 0.543 \
$)
Сгенерировано случайное число r = 0.343, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_2 = 0.312 < r = 0.343 \
P_3 = 0.457 >= r = 0.343 \
$)
Происходит переход на вершину 3. Далее приведены расчёты вероятностей перехода второго муравья c 3-й вершины:

#eq-simple($ p^2_32 = (0.438^1 * 0.773^2)/(0.00004) = 0.635 \
p^2_34 = (0.438^1 * 0.587^2)/(0.00004) = 0.365 \
$)
Сгенерировано случайное число r = 0.329, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_2 = 0.635 >= r = 0.329 \
$)
Происходит переход на вершину 2. Далее приведены расчёты вероятностей перехода второго муравья c 2-й вершины:

#eq-simple($ p^2_24 = (0.602^1 * 2.273^2)/(0.00031) = 1.000 \
$)
Сгенерировано случайное число r = 0.841, которое определяет, на какую из вершин будет совершён переход. Для этого рассчитанные вероятности складываются в накопительную сумму.

#eq-simple($ P_4 = 1.000 >= r = 0.841 \
$)
Происходит переход на вершину 4. Затем муравей возвращается на начальную вершину, и его путь завершается. Таким образом, путь второго муравья выглядит следующим образом: $0 -> 5 -> 4 -> 2 -> 1 -> 3 -> 0$. Длина пути равна: $15.0 + 181.52 + 168.27 + 129.36 + 44.0 + 232.04 = 770.178$.

Затем выполняется испарение феромона по Формуле @pher-vapor аналогично предыдущей итерации.

Изменение концентрации феромона происходит по Формуле @pher-update, где значение Q принято за 100. Далее отображены только значения феромонов, которые после данной итерации изменились на ненулевую величину. 

#eq-simple($ tau_16 = 0.376 + 0.258 = 0.634 \
tau_23 = 0.219 + 0.128 = 0.347 \
tau_24 = 0.301 + 0.130 = 0.431 \
tau_32 = 0.219 + 0.130 = 0.349 \
tau_34 = 0.219 + 0.128 = 0.347 \
tau_41 = 0.219 + 0.130 = 0.349 \
tau_45 = 0.301 + 0.128 = 0.429 \
tau_51 = 0.219 + 0.128 = 0.347 \
tau_53 = 0.301 + 0.130 = 0.431 \
tau_62 = 0.376 + 0.128 = 0.504 \
tau_65 = 0.219 + 0.130 = 0.349 \
$)

== Программная реализация

Для реализации расчётов алгоритма муравьиной колонии написан программный код на языке Python 3.12.

В программной реализации зафиксированы следующие параметры:
- количество вершин в графе: 10
- количество муравьёв: 10
- количество итераций: 40
- $α = 1$
- $beta = 5$
- $rho = 0.5$
- $Q = 100$
Код реализации алгоритма муравьиной колонии представлен в Листинге @ant-code.

На Рисунке @ant-res представлен результат выполнения программы для нахождение минимального пути в графе --- графики зависимости лучшего пути и среднего пути от номера итерации.

#figure(image("/img/prac4_ant-res.png", height: 40%), caption: [График зависимости длины пути от номера итерации])<ant-res>

На Рисунке @ant-path представлен лучший путь, построенный муравьями в результате выполнения алгоритма.

#figure(image("/img/prac4_ant-path.png"), caption: [Построенный путь])<ant-path>

== Выводы по разделу
В ходе выполнения данной работы выполнены поставленные задачи --- изучен муравьиный алгоритм, произведён его ручной расчёт для решения задачи коммивояжёра, а также разработаны программы на языке Python для нахождения оптимального пути в графе.

В заключение можно отметить, что муравьиный алгоритм является мощным инструментом для решения задач оптимизации, в которых стандартные методы недостаточно эффективны из-за наличия множества решений, среди которых нужно найти только одно оптимальное. Алгоритм отлично справляется с нахождением оптимальных путей в графе, однако его сходимость является не очень высокой, а также результативность алгоритма сильно зависит от настройки свободных параметров.

//
// АЛГОРИТМ ПЧЕЛИНОЙ КОЛОНИИ
// 

= Алгоритм пчелиной колонии
Алгоритм пчелиной колонии --- это эвристический метод оптимизации, разработанный Марко Дориго и Дино Д'Агостино в 2005 году. Этот алгоритм вдохновлен поведением медоносных пчел, которые демонстрируют удивительную способность находить наилучшие источники нектара для сбора меда.

Основной целью работы пчелиной колонии в природе является разведка пространства вокруг улья с целью поиска нектара с последующим его сбором. Для этого в составе колонии существуют различные типы пчел: пчелы-разведчики и рабочие пчелы-фуражиры (кроме них, в колонии существуют трутни и матка, не участвующие в процессе сбора нектара). Разведчики ведут исследование окружающего улей пространства и сообщают информацию о перспективных местах, в которых было обнаружено наибольшее количество нектара (для обмена информацией в улье существует специальный механизм, именуемый танцем пчелы).

Алгоритм пчелиной колонии моделирует это поведение. Вместо реальных пчел и танцев, алгоритм использует "искусственных пчел" и "искусственные танцы". Искусственные пчелы перемещаются по пространству поиска, представленному в виде графа или сетки, и оценивают качество каждой позиции. Затем они возвращаются в "улей" и передают информацию о найденных позициях другим пчелам. Вероятность выбора пчелой определенной позиции зависит от ее качества и количества информации, полученной от других пчел. Со временем, пчелы концентрируют свои усилия на наиболее перспективных позициях.

Алгоритм пчелиной колонии широко используется для решения различных задач оптимизации, таких как:
-	задача календарного планирования
-	задача коммивояжёра
-	транспортная задача


== Описание алгоритма
Сначала происходит инициализация начальных параметров и пчёл – генерация точек в области поиска (количество точек задано и равно S), а также свободных параметров алгоритма. Каждая точка имеет координаты (@bee-vec).


$ X_j=(x_(1 j),x_(2 j), dots ,x_(n j) ) " ," $<bee-vec>

#print_symbols(
  [$j in [1;S]$ --- номер частицы],
  [$n$ --- размерность векторов в задаче]
)

Формирование подобластей происходит на основе Евклидова расстояния между пчёлами (@bee-euclid).

$ d = sqrt((x_2 - x_1)^2 + (y_2 - y_1)^2) $<bee-euclid>

Сначала выбирается точка с наименьшим значением функции – она становится центром новой подобласти. Вокруг неё собираются все пчёлы, расстояние до которых от центральной пчелы меньше заданного числа $epsilon$. После проверки всех пчёл убираются те пчёлы, которые вошли в подобласть, и данные действия повторяются для оставшихся пчёл.

После формирования подобластей начинается поиск оптимального значения в каждой из них. В каждой области выбирается точка с наилучшим значение функции, вокруг неё в квадрате со стороной $2 Delta$ генерируются случайным образом $S-1$ пчёл, а затем среди сгенерированных пчёл и центральной пчелы выбирается та, которая имеет наименьшее значение функции. Теперь эта точка становится центром новой области, и процесс повторяется до тех пор, пока не наилучшая точка не останется статичной в течение заданного числа итераций.

Такой поиск проводится в каждой из полученных подобластей, и точкой останова алгоритма является окончание поиска в последней области. 

Точкой останова алгоритма является выполнение заданного числа итераций.

== Постановка задачи

Цель работы: реализовать глобальный алгоритм роя частиц для нахождения оптимального значения функции.

Поставлены следующие задачи:

- изучить алгоритм пчелиной колонии
- выбрать тестовую функцию для оптимизации (нахождение глобального минимума)
- произвести ручной расчёт одной итерации алгоритма
- разработать программную реализацию алгоритма пчелиной колонии для задачи минимизации функции

Выбранная функция для оптимизации: функция Растригина (@rastrigin-3). Она примечательна тем, что имеет большое количество локальных минимумов. Глобальный минимум функции достигается в точке $(0;0)$ и равен 0, при этом, в остальных локальных минимумах значение функции больше нуля. Функция рассматривается на области $x_i in [-5.12,5.12]$.

$ f(x,y)=20+x^2-10 cos(2 pi x)+y^2-10 cos(2 pi y) $<rastrigin-3>

== Ручной расчёт алгоритма

Выбранная функция: функция Растригина от двух переменных. Её формула представлена Формулой @rastrigin-3.
На Рисунке @rastrigin-im-3 представлен график этой функции.
#figure(image("/img/prac5_2025-02-06-17-10-37.png"), caption: [График функции Растригина])<rastrigin-im-3>
Инициализированы свободные параметры алгоритма:
- $epsilon = 2$
- $Delta = 1$
- количество пчёл-разведчиков (S): 8

Создано 8 пчёл со следующими координатами:

#eq-simple($ X_1 = (-4.078, -5.091); f(X_0) = 45.310 \
X_2 = (4.723, -2.923); f(X_1) = 43.654 \
X_3 = (3.593, 3.706); f(X_2) = 57.682 \
X_4 = (-0.960, 3.632); f(X_3) = 31.198 \
X_5 = (3.945, -2.769); f(X_4) = 32.614 \
X_6 = (1.065, 4.941); f(X_5) = 27.056 \
X_7 = (4.918, 4.094); f(X_6) = 43.920 \
X_8 = (-1.068, 1.670); f(X_7) = 19.633 \
$)
Среди оставшихся точек лучшее значение имеется у пчелы $X_8$: значение функции у неё равно 19.633.
Далее рассчитывается Евклидово расстояние между точкой $X_8$ и оставшимися точками по Формуле @rastrigin-3.
#eq-simple($
d_(8 1) = sqrt((-1.068 + 4.078)^2 + (1.670 + 5.091)^2) = 7.401 >= 2 \
d_(8 2) = sqrt((-1.068 - 4.723)^2 + (1.670 + 2.923)^2) = 7.392 >= 2 \
d_(8 3) = sqrt((-1.068 - 3.593)^2 + (1.670 - 3.706)^2) = 5.087 >= 2 \
d_(8 4) = sqrt((-1.068 + 0.960)^2 + (1.670 - 3.632)^2) = 1.964 < 2 \
d_(8 5) = sqrt((-1.068 - 3.945)^2 + (1.670 + 2.769)^2) = 6.696 >= 2 \
d_(8 6) = sqrt((-1.068 - 1.065)^2 + (1.670 - 4.941)^2) = 3.904 >= 2 \
d_(8 7) = sqrt((-1.068 - 4.918)^2 + (1.670 - 4.094)^2) = 6.458 >= 2 \
$)
Следовательно, в область точки $X_8$ вошла точка $X_4$.

Среди оставшихся точек лучшее значение имеется у пчелы $X_6$: значение функции у неё равно 27.056.

Далее рассчитывается Евклидово расстояние между точкой $X_6$ и оставшимися точками по Формуле @rastrigin-3.
#eq-simple($
d_(6 1) = sqrt((1.065 + 4.078)^2 + (4.941 + 5.091)^2) = 11.273 >= 2 \
d_(6 2) = sqrt((1.065 - 4.723)^2 + (4.941 + 2.923)^2) = 8.673 >= 2 \
d_(6 3) = sqrt((1.065 - 3.593)^2 + (4.941 - 3.706)^2) = 2.813 >= 2 \
d_(6 5) = sqrt((1.065 - 3.945)^2 + (4.941 + 2.769)^2) = 8.230 >= 2 \
d_(6 7) = sqrt((1.065 - 4.918)^2 + (4.941 - 4.094)^2) = 3.945 >= 2 \
$)
Следовательно, точка $X_6$ образует область сама с собой.

Среди оставшихся точек лучшее значение имеется у пчелы $X_5$: значение функции у неё равно 32.614.

Далее рассчитывается Евклидово расстояние между точкой $X_5$ и оставшимися точками по Формуле @rastrigin-3.
#eq-simple($
d_(5 1) = sqrt((3.945 + 4.078)^2 + (-2.769 + 5.091)^2) = 8.352 >= 2 \
d_(5 2) = sqrt((3.945 - 4.723)^2 + (-2.769 + 2.923)^2) = 0.794 < 2 \
d_(5 3) = sqrt((3.945 - 3.593)^2 + (-2.769 - 3.706)^2) = 6.485 >= 2 \
d_(5 7) = sqrt((3.945 - 4.918)^2 + (-2.769 - 4.094)^2) = 6.932 >= 2 \
$)
Следовательно, в область точки $X_5$ вошла точка $X_2$.

Среди оставшихся точек лучшее значение имеется у пчелы $X_7$: значение функции у неё равно 43.920.

Далее рассчитывается Евклидово расстояние между точкой $X_7$ и оставшимися точками по Формуле @rastrigin-3.
#eq-simple($
d_(7 1) = sqrt((4.918 + 4.078)^2 + (4.094 + 5.091)^2) = 12.856 >= 2 \
d_(7 3) = sqrt((4.918 - 3.593)^2 + (4.094 - 3.706)^2) = 1.380 < 2 \
$)
Следовательно, в область точки $X_7$ вошла точка $X_3$.

Среди оставшихся точек лучшее значение имеется у пчелы $X_1$: значение функции у неё равно 45.310.

Поскольку точек больше не осталось, то точка $X_1$ образует область сама с собой.

Рассмотрим поиск в первой подобласти. Лучшая точка: $(-1.068, 1.670)$ со значением функции 19.633.
Новые сгенерированные точки имеют следующие координаты (точка $X_8$ является текущим центром области):

#eq-simple($ X_1 = (-0.822, 0.917); f(X_0) = 8.453 \
X_2 = (-1.212, 2.105); f(X_1) = 15.630 \
X_3 = (-0.196, 1.449); f(X_2) = 28.284 \
X_4 = (-0.845, 0.943); f(X_3) = 6.618 \
X_5 = (-0.775, 0.699); f(X_4) = 22.633 \
X_6 = (-0.826, 2.319); f(X_5) = 25.707 \
X_7 = (-1.464, 2.197); f(X_6) = 33.421 \
X_8 = (-1.068, 1.670); f(X_7) = 19.633 \
$)
Минимальное значение среди достигнуто точкой $X_4$ (значение функции равно 6.618). Следовательно, эта точка становится центром области, и происходит переход к новой итерации.

== Программная реализация
Для реализации расчётов алгоритма пчелиной колонии написан программный код на языке Python.

В программной реализации зафиксированы следующие параметры:
- количество пчёл: 100
- количество итераций: 30
- $epsilon=0.8$
- $Delta=1$
Код реализации алгоритма пчелиной колонии для нахождения оптимального значения функции представлен в Листинге @bee-code.

На Рисунке @bee-result представлен результат выполнения программы для нахождения оптимального значения функции – консольный вывод результатов поиска в нескольких областях. 

#figure(image("/img/prac5_2025-02-06-17-28-30.png"), caption: [Результаты поиска в первых 12 областях])<bee-result>

== Выводы по разделу
В ходе выполнения данной работы выполнены поставленные задачи –-- изучен алгоритм пчелиной колонии, произведён его ручной расчёт для решения задачи поиска глобального минимума функции, а также разработана программа на языке Python для нахождения глобального минимума функции Растригина от двух переменных.

В заключение можно отметить, что алгоритм пчелиной колонии является мощным инструментом для решения задач оптимизации (в том числе, задач нахождения глобального минимума функции), в которых стандартные методы недостаточно эффективны из-за наличия множества локальных минимумов. Алгоритм имеет высокую сходимость, однако его результативность сильно зависит от настройки большого количества свободных параметров.

//
// ЭЛЕКТРОМАГНИТНЫЙ АЛГОРИТМ
// 

= Электромагнитный алгоритм
Электромагнитный алгоритм предложен Бирбилом (I. Birbil) и Фангом (S.C. Fang) в 2003 году [2]. Этот алгоритм вдохновлен фундаментальными принципами электромагнетизма, а именно взаимодействием между электрическими зарядами и магнитными полями.

В алгоритме пространство поиска представляется как заполненное частицами, каждая из которых обладает определенным электрическим зарядом. Эти частицы взаимодействуют друг с другом посредством электромагнитных сил. Сила притяжения или отталкивания между двумя частицами зависит от их зарядов и расстояния между ними.

Каждого из агентов популяции в электромагнитном алгоритме интерпретируют как заряженную частицу, заряд которой пропорционален значению фитнесс-функции в той точке области поиска, в которой на данной итерации находится агент. Текущий заряд частиц популяции определяет суммарную силу, действующую на данную частицу со стороны других частиц, а также направление и величину её перемещений на текущей итерации. В соответствии с законами электростатики эта сила вычисляется путём векторного суммирования сил притяжения и отталкивания со стороны всех частиц популяции [2].

Электромагнитный алгоритм широко используется для решения различных задач оптимизации, таких как:
-	задача коммивояжера
-	распределение ресурсов
-	планирование
-	сетевое проектирование

== Описание алгоритма
Сначала происходит инициализация начальных параметров и зарядов – генерация точек в области поиска (количество точек задано и равно S), а также свободных параметров алгоритма. Каждая точка имеет координаты @electro-coord.

$ X_j=(x_1j,x_2j,…,x_(n j) )	$<electro-coord>

#print_symbols(
  [$j in [1;S]$ --- номер частицы],
  [n --- размерность векторов в задаче]
)

Затем начинается локальный поиск – для каждого заряда выполняется линейный стохастический поиск @local-search в целях сбора локальной информации об окружении частиц [2, c.22-23].

$ x_(i j)^'= x_(i j) + u^"sign" * U(0;1) * alpha (x^+ - x^-) $<local-search>

#print_symbols(
  [$u^"sign"$ --- случайное целое число, равное -1 или 1],
  [$U(0;1)$ --- случайное число от 0 до 1 из равномерного распределения],
  [$alpha in (0;1)$ --- свободный параметр алгоритма],
  [$x^+, x^-$ --- границы рассматриваемой области поиска]
)

При этом, изменённая координата принимается только в том случае, если её изменение дало улучшение значения целевой функции, иначе происходит переход к следующей итерации локального поиска.

Как правило, свободный параметр $alpha$ задаётся близким к нулю (порядка $~10^(-2):10^(-4)$), поэтому локальный поиск служит только для незначительного улучшения положения точек в пространстве.

После осуществления локального поиска вычисляется лучшая точка, т.е. точка, где достигается минимальное среди всех значение целевой функции.

Затем для каждой частицы вычисляется её заряд по Формуле @charge.

$ q_i = exp(-n * ( (φ_i-φ_"best" ) ) / ( sum_(j, j cancel(eq) i) (φ_j-φ_"best" ) )) $<charge>

#print_symbols(
  [$phi_i$ --- значение целевой функции в текущей точке],
  [$phi_"best"$ --- значение целевой функции в лучшей точке]
)

На основе посчитанных зарядов происходит вычисление силы отталкивания и притяжения между частицами (@force). Частица i отталкивается от частицы j, если значение функции у частицы i лучше, чем значение функции у частицы j, и наоборот, притягивается, если значение функции хуже.

$ F_i = sum_(j=1, j cancel(eq) i)^S F_(i,j) = sum_(j=1, j cancel(eq) i)^S cases(
  (X_j - X_i) frac(q_i q_j, ||X_j - X_i||^2) ", если " phi_j < phi_i,
  (X_i - X_j) frac(q_i q_j, ||X_j - X_i||^2) ", если " phi_i < phi_j
) $<force>

Таким образом, лучшая частица на данной итерации притянет к себе все остальные. Далее выполняется перемещение частиц, высчитываемое на основе электромагнитных сил (@electro-change).

$ X_i (t+1) = X_i (t) + U(0;1) F_i/(||F_i||) V_i $<electro-change>

#print_symbols(
  [$U(0;1)$ --- случайное число от 0 до 1 из равномерного распределения],
  [$frac(F_i, || F_i ||)$ --- нормированный вектор силы],
  [$V_i$ --- вектор скорости, компоненты которого рассчитываются по Формуле @electro-speed]
)

$ v_(i j) = cases(
  (x^+ - x_(i j)) ", " F_(i j) > 0,
  (x_(i j) - x^-) ", " F_(i j) <= 0
) ", " j in [1:S] ", " j != i $<electro-speed>

#print_symbols(
  [$x^+,x^-$ --- границы области поиска]
)

Важно отметить, что лучшая частица должна остаться на своём месте, поэтому она в данной итерации не передвигается, а только притягивает к себе другие частицы.

После осуществления перемещения частиц происходит переход к следующей итерации. Точкой останова алгоритма является достижение максимального числа итераций.


== Постановка задачи

Цель работы: реализовать электромагнитный алгоритм для нахождения оптимального значения функции.

Поставлены следующие задачи:

- изучить электромагнитный алгоритм
- выбрать тестовую функцию для оптимизации (нахождение глобального минимума)
- произвести ручной расчёт одной итерации алгоритма
- разработать программную реализацию электромагнитного алгоритма для задачи минимизации функции

Выбранная функция для оптимизации: функция Растригина (@rastrigin-4). Она примечательна тем, что имеет большое количество локальных минимумов. Глобальный минимум функции достигается в точке $(0;0)$ и равен 0, при этом, в остальных локальных минимумах значение функции больше нуля. Функция рассматривается на области $x_i in [-5.12,5.12]$.

$ f(x,y)=20+x^2-10 cos(2 pi x)+y^2-10 cos(2 pi y) $<rastrigin-4>

== Ручной расчёт алгоритма

Выбранная функция: функция Растригина от двух переменных. Её формула представлена Формулой @rastrigin-4.
На Рисунке @rastrigin-im-4 представлен график этой функции.

#figure(image("/img/prac6_2025-02-07-17-16-04.png"), caption: [График функции Растригина])<rastrigin-im-4>

Количество частиц, используемых для ручного расчёта: 4.

Создано 4 частицы со следующими координатами:

#eq-simple($ X_1 = (-1.911, 2.375); f(X_0) = 27.905 \
X_2 = (3.325, 4.537); f(X_1) = 65.893 \
X_3 = (3.839, -2.436); f(X_2) = 44.592 \
X_4 = (0.141, -1.939); f(X_3) = 8.157 \
$)
После выполнения локального поиска (@local-search) точки имеют следующие координаты:

#eq-simple($ X_1 = (-1.911, 2.368); f(X_0) = 27.550 \
X_2 = (3.291, 4.537); f(X_1) = 63.706 \
X_3 = (3.873, -2.436); f(X_2) = 43.152 \
X_4 = (0.141, -1.961); f(X_3) = 7.813 \
$)
При этом, значение $phi_"best"$ равно 7.813 в точке $(0.141, -1.961)$.
Далее приведены расчёты значения заряда для каждой из частиц по Формуле @charge:

#eq-simple($ q_1 = exp(-2 * (27.550 - 7.813)/110.971) = 0.701 \
q_2 = exp(-2 * (63.706 - 7.813)/110.971) = 0.365 \
q_3 = exp(-2 * (43.152 - 7.813)/110.971) = 0.529 \
$)
При этом, заряд у лучшей частицы будет равен единице, поскольку аргумент в экспоненте будет равен нулю.
Затем вычисляются значение силы для каждой частицы по Формуле @force:

#eq-simple($ F_1 =& 0.701 * 0.365 * ((-1.911, 2.368) - (3.291, 4.537))/31.766 + \ &+ 0.701 * 0.529 * ((-1.911, 2.368) - (3.873, -2.436))/56.543 + \ &+ 0.701 * 1.000 * ((0.141, -1.961) - (-1.911, 2.368))/22.953 = (-0.017, -0.118) \
F_2 =& 0.365 * 0.701 * ((-1.911, 2.368) - (3.291, 4.537))/31.766 + \ &+ 0.365 * 0.529 * ((3.873, -2.436) - (3.291, 4.537))/48.965 + \ &+ 0.365 * 1.000 * ((0.141, -1.961) - (3.291, 4.537))/52.152 = (-0.062, -0.09) \    
F_3 =& 0.529 * 0.701 * ((-1.911, 2.368) - (3.873, -2.436))/56.543 + \ &+ 0.529 * 0.365 * ((3.873, -2.436) - (3.291, 4.537))/48.965 + \ &+ 0.529 * 1.000 * ((0.141, -1.961) - (3.873, -2.436))/14.160 = (-0.175, 0.022) \  
F_4 =& 1.000 * 0.701 * ((0.141, -1.961) - (-1.911, 2.368))/22.953 + \ &+ 1.000 * 0.365 * ((0.141, -1.961) - (3.291, 4.537))/52.152 + \ &+ 1.000 * 0.529 * ((0.141, -1.961) - (3.873, -2.436))/14.160  = (-0.099, -0.16) 
\
$)

И наконец, позиции частиц изменяются по Формулам @electro-change - @electro-speed. Частица $X_4$ не передвигается, т.к. она имеет лучшее значение.

Рассчитаем смещение для 1-й частицы. Сгенерировано случайное число $U(0;1) = 0.845$.

Нормированный вектор силы у 1-й частицы: $F_1 = (-0.144, -0.99)$.

Рассчитаны компоненты вектора скорости для 1-й частицы:

#eq-simple($ v_11 = -1.911 + 5.12 = 3.209 \
v_12 = 2.368 + 5.12 = 7.488 \
$)
Тогда частица сместится на следующую позицию:

#eq-simple($ X_1 &= (-1.911, 2.368) + 0.845 * (-0.144, -0.99) * (3.209, 7.488) \ &= (-2.301, -3.891) \
F(X_1) &= 35.864
$)

Рассчитаем смещение для 2-й частицы. Сгенерировано случайное число $U(0;1) = 0.403$
Нормированный вектор силы у 2-й частицы: $F_2 = (-0.563, -0.826)$
Рассчитаны компоненты вектора скорости для 2-й частицы:

#eq-simple($ v_21 = 3.291 + 5.12 = 8.411 \
v_22 = 4.537 + 5.12 = 9.657 \
$)
Тогда частица сместится на следующую позицию:

#eq-simple($ X_2 &= (3.291, 4.537) + 0.403 * (-0.563, -0.826) * (8.411, 9.657) \ &= (1.38, 1.317) \
F(X_2) &= 35.025
$)

Рассчитаем смещение для 3-й частицы. Сгенерировано случайное число $U(0;1) = 0.767$
Нормированный вектор силы у 3-й частицы: $F_3 = (-0.992, 0.123)$
Рассчитаны компоненты вектора скорости для 3-й частицы:

#eq-simple($ v_31 = 3.873 + 5.12 = 8.993 \
v_32 = 5.12 + 2.436 = 7.556 \
$)
Тогда частица сместится на следующую позицию:

#eq-simple($ X_3 &= (3.873, -2.436) + 0.767 * (-0.992, 0.123) * (8.993, 7.556) \ &= (-2.973, -1.722) \
F(X_3) &= 23.689
$)

== Программная реализация
Для реализации расчётов электромагнитного алгоритма написан программный код на языке Python.

В программной реализации зафиксированы следующие параметры:

- количество частиц: 20
- количество итераций локального поиска: 10
- количество общих итераций: 100
- $alpha = 0.005$

Код реализации электромагнитного алгоритма для нахождения оптимального значения функции представлен в Листинге @electro-code.

На Рисунке @electro-result представлен результат выполнения программы для нахождения оптимального значения функции – график зависимости минимального оптимального решения от номера итерации. 

#figure(image("/img/prac6_2025-02-07-17-42-30.png"), caption: [Результат выполнения программы])<electro-result>

== Выводы по разделу
В ходе выполнения данной работы выполнены поставленные задачи – изучен электромагнитный алгоритм, произведён его ручной расчёт для решения задачи поиска глобального минимума функции, а также разработаны программы на языке Python для нахождения глобального минимума функции Растригина от двух переменных.

В заключение можно отметить, что электромагнитный алгоритм является мощным инструментом для решения задач оптимизации (например, для нахождения глобального минимума функции от нескольких переменных), в которых стандартные методы недостаточно эффективны из-за наличия множества локальных минимумов. Алгоритм имеет меньшую зависимость от свободных параметров, чем пчелиный алгоритм, но большую, чем роевой алгоритм. В то же время, алгоритм показал быструю сходимость, однако имеет тенденцию сходится к локальным минимумам.


//
// Заключение
// 

#heading("Заключение", numbering: none)
В ходе выполнения работы изучены основы системного анализа данных и применения онтологий, а также изучены и реализованы различные методы оптимизации, вдохновлённые природой.
Разработана онтология музыкальной индустрии, включающая классы, слоты и экземпляры. Онтология включает в себя 4 класса, позволяющие описать простые отношения внутри выбранной области. Для описания онтологии использован инструмент Protégé, также он используется для написания запросов на получение объектов по различным атрибутам. Также написана программа на языке Python для описания онтологии и написания запросов.

Для решения задачи коммивояжёра и задачи оптимизации функций от многих переменных реализовано несколько алгоритмов, позволяющих быстро найти оптимальное решение в поставленной задаче.

Метод имитации отжига является простым алгоритмом, который существенно полагается на случайную генерацию, однако за счёт механизма отжига, когда при высокой температуре может быть принято неоптимальное решение, алгоритм показывает хорошие результаты при решении как задачи коммивояжёра, так и задачи нахождения глобального минимума функции от нескольких переменных.

Роевой алгоритм предназначен для оптимизации функций, но находит более оптимальное решение, чем метод имитации отжига. При этом, он является простым в реализации и не требует сложной метаоптимизации.

Муравьиный алгоритм предназначен для решения задачи коммивояжёра, и имеет хорошую сходимость к оптимальному решению. Однако значительным недостатком алгоритма является зависимость от большого количества свободных аргументов, поскольку при неверной их комбинации алгоритм показывает неудовлетворительные результаты.

Алгоритм пчелиной колонии предназначен для нахождения глобального минимума функций. Алгоритм имеет хорошую сходимость и лучше сходится к оптимальному решению по сравнению с роевым алгоритмом, однако недостатком является зависимость от регулирования свободных параметров.

Электромагнитный алгоритм предназначен для оптимизации функций. Свободные параметры меньше влияют на данный алгоритм по сравнению с алгоритмом пчелиной колонии, при этом алгоритм показывает лучшие показатели сходимости к глобальному минимуму.

Все описанные алгоритмы реализованы на языке Python для решения задачи коммивояжёра в произвольном графе и нахождения глобального минимума функции Растригина, которая примечательна наличием большого количества локальных минимумов.


#bibliography("/authors.bib", style: "/gost-r-7-0-5-2008-numeric-alphabetical.csl", title: "Список использованных источников", full: true)

#appendix()

==== Код реализации онтологии на языке Python

#simple-code(raw(read("/include/prac1.py")),
             "Код файла main.py",
             label: <ont>)

==== Код реализации метода имитации отжига в задаче коммивояжёра на языке Python

#simple-code(raw(read("/include/generate.py")),
             "Код файла generate.py",
             label: <otzhig-gen>)

#simple-code(raw(read("/include/backup_10.csv")),
             "Код файла data.csv",
             label: <otzhig-data>)

#simple-code(raw(read("/include/non_weight.py")),
             "Код файла main.py",
             label: <otzhig>)


==== Код реализации метода имитации отжига в задаче оптимизации функции на языке Python

#simple-code(raw(read("/include/glob_min.py")),
             "Реализация метода имитации отжига",
             label: <cauchy-code>)

==== Реализация роевого алгоритма в задаче оптимизации на языке Python

#simple-code(raw(read("/include/swarm.py")),
             "Реализация роевого алгоритма",
             label: <swarm-code>)

==== Реализация муравьиного алгоритма на языке Python

#simple-code(raw(read("/include/simple_ant_algorithm.py")),
             "Реализация муравьиного алгоритма",
             label: <ant-code>)

==== Реализация алгоритма пчелиной колонии на языке Python

#simple-code(raw(read("/include/bee_algorithm.py")),
             "Реализация алгоритма пчелиной колонии",
             label: <bee-code>)

==== Реализация электромагнитного алгоритма на языке Python

#simple-code(raw(read("/include/electro.py")),
             "Реализация электромагнитного алгоритма",
             label: <electro-code>)