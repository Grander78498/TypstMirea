#import ("/src/titul.typ"): *
#import ("/src/preamble.typ"): *
#show: main
#titul(
  Институт: [Информационных Технологий],
  Кафедра: [Вычислительной Техники],
  Практика: [Практическая работа №3\
            "Алгоритм роя частиц"],
  Дисциплина: ["Системный анализ данных СППР"],
  Группа: [ИКБО-04-22],
  Студент: [Егоров Л.А.],
  Преподаватель: [Железняк Л.М.]
)
#show: template

#outline()


//
// ВВЕДЕНИЕ
// 

#let intro = [
В основу алгоритма оптимизации роем частиц положена социально-психологическая поведенческая модель толпы. Развитие алгоритма инспирировали такие задачи, как моделирование поведения птиц в стае и рыб в косяке. Целью было обнаружить базовые принципы, благодаря которым, например, птицы в стае ведут себя удивительно синхронно, меняя как по команде направления своего движения, так что стая движется как единое целое. К современному времени концепция алгоритма роя частиц развилась в высокоэффективный алгоритм оптимизации, часто составляющий конкуренцию лучшим модификациям генетического алгоритма.

В настоящее время роевой алгоритм применяются при решении задач численной и комбинаторной оптимизации, обучении искусственных нейронных сетей, построении нечетких контроллеров и т.д. в различных областях науки техники:

-	управление энергетическими системами
-	решение NP-трудных комбинаторных проблем
-	задачи календарного планирования
-	оптимизация в мобильной связи
-	оптимизация процессов пакетной обработки
-	оптимизация многокритериальных задач
-	обработка изображений; распознавание образов
-	кластеризация данных
-	биоинформатика
-	проектирование сложных технических систем и т.д
]

//
// ОСНОВНАЯ ЧАСТЬ
// 

#let main = [
== Описание алгоритма
Сначала происходит инициализация начальных параметров и роя --- генерация точек в области поиска (количество точек задано и равно S), а также свободных параметров алгоритма. Каждая точка имеет координаты и вектор скорости (@swarm-coord).

$ x_k = (x_1^k, x_2^k, dots, x_n^k); v_k = (v_1^k, v_2^k, dots, v_n^k), $<swarm-coord>

#print_symbols([$k$ --- номер частицы],
               [$n$ --- размерность векторов в задаче])

Далее происходит поиск лучшего решения для каждой частицы, после которого обновляется лучшее решение для всего роя, если какой-то частицей найдено решение, которое лучше текущего.
Затем выполняется коррекция скорости для каждой частицы по Формуле @swarm-speed.

$ v_i (t+1) = v_i (t)+c_1 r_1 (t)(y_i (t)-x_i (t))+c_2 r_2 (t)(y ̂(t)-x_i (t)), $<swarm-speed>

#print_symbols([$c_1,c_2$ --- положительные коэффициенты ускорения],
                [$r_1 (t),r_2 (t)$ --- вектора размерности $n$, состоящие из случайных чисел из диапазона $(0; 1)$; при этом, $r_2 (t)=1-r_1 (t)$],
                [$y_i (t)$ --- позиция i-й частицы, где достигалось лучшее решение],
                [$y (t)$ --- координаты частицы с лучшим решением всего роя])

После этого выполняется коррекция позиции каждой частицы по Формуле @correct-pos.

$ x_i (t+1)=x_i (t)+v_i (t+1) $<correct-pos>

Точкой останова алгоритма является выполнение заданного числа итераций.

== Постановка задачи

Цель работы: реализовать глобальный алгоритм роя частиц для нахождения оптимального значения функции.

Поставлены следующие задачи:

- изучить алгоритм роя частиц
- выбрать тестовую функцию для оптимизации (нахождение глобального минимума)
- произвести ручной расчёт двух итераций алгоритма для трёх частиц
- разработать программную реализацию алгоритма роя частиц для задачи минимизации функции

Выбранная функция для оптимизации: функция Растригина (@rastrigin-2). Она примечательна тем, что имеет большое количество локальных минимумов. Глобальный минимум функции достигается в точке $(0;0)$ и равен 0, при этом, в остальных локальных минимумах значение функции больше нуля. Функция рассматривается на области $x_i in [-5.12,5.12]$.

$ f(x,y)=20+x^2-10 cos(2 pi x)+y^2-10 cos(2 pi y) $<rastrigin-2>

== Ручной расчёт алгоритма

Выбранная функция: функция Растригина от двух переменных. Её формула представлена Формулой @rastrigin-2.
На Рисунке @rastrigin-im-2 представлен график этой функции.

#figure(image("/img/prac3_rastrigin.png", height: 12%), caption: [График функции Растригина])<rastrigin-im-2>

Инициализированы свободные параметры алгоритма:

- $c_1=c_2=2$
- количество частиц: 3
Далее созданы три частицы со следующими характеристиками:

#eq-simple($x_1=(0.2,3.5);v_1=(0,0)\
x_2=(1.3,0.98);v_2=(0,0)\
x_3=(4.87,-3.1);v_3=(0,0)$)

Значение целевой функции в первой точке равно 39.2; значение целевой функции у второй частицы равно 15.82; значение целевой функции у третьей частицы равно 38.39.

Лучшая позиция у каждой частицы пока что считается равной текущей позиции каждой частицы, а лучшая позиция всего роя --- у второй частицы.

Затем выполняется коррекция скорости по Формуле @swarm-speed. Для коррекции скорости первой частицы сгенерирован двумерный вектор из случайных чисел $r_1=(0.234,0.567)$.

#eq-simple($v_11 (1)=0+2*0.234*(0.2-0.2)+2*(1-0.234)*(1.3-0.2)=1.685 \
v_12 (1)=0+2*0.567*(3.5-3.5)+2*(1-0.567)*(0.98-3.5)=-2.182$)

Для коррекции скорости второй частицы сгенерирован двумерный вектор из случайных чисел $r_2=(0.123,0.987)$.

#eq-simple($v_21 (1)=0+2*0.123*(1.3-1.3)+2*(1-0.123)*(1.3-1.3)=0\
v_22 (1)=0+2*0.987*(0.98-0.98)+2*(1-0.987)*(0.98-0.98)=0$)

Для коррекции скорости третьей частицы сгенерирован двумерный вектор  из случайных чисел $r_2=(0.555,0.002)$.

#eq-simple($v_31 (1)=0+2*0.555*(4.87-4.87)+2*(1-0.555)(1.3-4.87)=-3.177\
v_32 (1)=0+2*0.002*(-3.1+3.1)+2*(1-0.002)*(0.98+3.1)=8.144$)

После коррекции скоростей выполняется коррекция координат каждой из частиц:

#eq-simple($x_11 (1)=0.2+1.685=1.885\
x_12 (1)=3.5-2.182=1.318\
x_21 (1)=1.3+0=1.3\
x_22 (1)=0.98+0=0.98\
x_31 (1)=4.87-3.177=1.693\
x_32 (1)=-3.1+8.144=5.044$)

После этого происходит переход ко второй итерации. Заново рассчитаны значения функции у каждой частицы:

#eq-simple($f_1 (1)=21.93\
f_2 (1)=15.82\
f_3 (1)=42.19$)

Значение целевой функции у первой частицы улучшилось, поэтому лучшая позиция теперь $(1.885, 1.318)$. Значение целевой функции у второй частицы не изменилось, поэтому её лучшая позиция осталась $(1.3, 0.98)$. Значение целевой функции у третьей частицы ухудшилось, поэтому лучшая позиция у третьей частицы остаётся как была изначально: $(4.87, -3.1)$. Лучшая позиция всего роя остаётся у второй частицы.

Затем выполняется коррекция скорости по Формуле @swarm-speed. Для коррекции скорости первой частицы сгенерирован двумерный вектор из случайных чисел $r_1=(0.124,0.5)$.

#eq-simple($v_11 (2) = 1.685 + 2 * 0.124 * (1.885 - 1.885) &+ \
           + 2 * (1-0.124)*(1.3-1.885)&=0.66\
          v_12 (2)=0+2*0.5*(1.318-1.318)&+\ 
          +2*(1-0.5)*(0.98-1.318)&=-0.33$)

Для коррекции скорости второй частицы сгенерирован двумерный вектор из случайных чисел $r_2=(0.01,0.8)$.

#eq-simple($v_21 (2)=0+2*0.01*(1.3-1.3)+2*(1-0.01)*(1.3-1.3)=0\
v_22 (2)=0+2*0.8*(0.98-0.98)+2*(1-0.8)*(0.98-0.98)=0$)

Для коррекции скорости третьей частицы сгенерирован двумерный вектор  из случайных чисел $r_3=(0.4,0.8)$.

#eq-simple($v_31 (2)=0+2*0.4*(4.87-1.693)+2*(1-0.4)*(1.3-1.693)=2.07\
v_32 (2)=0+2*0.8*(-3.1-5.044)+2*(1-0.8)*(0.98-5.044)=-14.656$)

После коррекции скоростей выполняется коррекция координат каждой из частиц:

#eq-simple($x_11 (1)=1.885+0.66=2.545\
x_12 (1)=1.318-0.33=0.988\
x_21 (1)=1.3+0=1.3\
x_22 (1)=0.98+0=0.98\
x_31 (1)=1.693+2.07=3.763\
x_32 (1)=5.044-14.656=-9.612$)

Но координата $x_32$ получилась вне области поиска, поэтому она принимается равной -5.12, т.е. позиция третьей частицы: $(3.763, -5.12)$.
Заново рассчитаны значения функции у каждой частицы:

#eq-simple($f_1 (2)=27.08\
f_2 (2)=15.82\
f_3 (2)=52.27$)

== Программная реализация

Для реализации расчётов алгоритма роя частиц написан программный код на языке Python.

В программной реализации зафиксированы следующие параметры:

-	количество частиц: 20
-	количество итераций: 30
-	$c_1$ и $c_2$: 2

Код реализации роевого алгоритма для нахождения оптимального значения функции представлен в Листинге @swarm-code.

На Рисунке @swarm-res представлен результат выполнения программы для нахождения оптимального значения функции --- график зависимости оптимального решения от номера итерации. 

#figure(image("/img/prac3_swarm-res.png"), caption: [График зависимости оптимального значения функции от номера итерации])<swarm-res>
]

//
// ЗАКЛЮЧЕНИЕ
// 

#let outro = [
В ходе выполнения данной работы выполнены поставленные задачи --- изучен алгоритм роя частиц, произведён его ручной расчёт для решения задачи поиска глобального минимума функции, а также разработаны программы на языке Python для нахождения глобального минимума функции Растригина от двух переменных.

В заключение можно отметить, что роевой алгоритм является мощным инструментом для решения задач оптимизации, в которых стандартные методы недостаточно эффективны из-за наличия множества локальных минимумов. При этом, алгоритм является простым в реализации и имеет мало свободных параметров, из-за чего алгоритм не нуждается в длительной метаоптимизации.
]

//
// ПРИЛОЖЕНИЯ
// 

#let app = [
====== Реализация роевого алгоритма в задаче оптимизации на языке Python

#simple-code(raw(read("/include/swarm.py")),
             "Реализация роевого алгоритма",
             label: <swarm-code>)
]

#heading("Введение", numbering: none)
#intro

= Алгоритм роя частиц
#main

#heading("Заключение", numbering: none)
#outro



#bibliography("/authors.bib", style: "/src/gost-r-7-0-5-2008-numeric-alphabetical.csl", title: "Список использованных источников", full: true)

#appendix()

#app
